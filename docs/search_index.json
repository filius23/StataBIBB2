[["appendix.html", "10 Anhang - fortgeschrittene Themen 10.1 Gewichtung in Stata 10.2 Import und Aufbereitung aus Excel 10.3 adopath 10.4 log file 10.5 Beobachtungen markieren mit gen &amp; if 10.6 macros", " 10 Anhang - fortgeschrittene Themen 10.1 Gewichtung in Stata Bei der Datenanalyse ist man oft mit einer Stichprobe aus einer größeren Population konfrontiert und man möchte aus dieser Stichprobe Rückschlüsse auf die größere Population ziehen. Die meisten statistischen Verfahren für diese sog. Inferenzstatistik beruhen dabei auf der Annahme, dass die Stichprobe eine einfache Zufallsstichprobe ist. Bei einer solchen Stichprobe gelangen alle Elemente der Grundgesamtheit mit der gleichen Wahrscheinlichkeit in die Stichprobe. In der Praxis sind solche Stichproben aber die große Ausnahme. Häufig haben bestimmte Gruppen von Personen höhere Auswahlwahrscheinlichkeiten als andere. Kohler/Kreuter, S.1 Grundsätzlich sind in Stata drei Arten der Gewichtung verfügbar: pweight \\(\\Rightarrow\\) die Beobachtungen aus der Grundgesamtheit haben eine unterschiedliche Wahrscheinlichkeit, in der Stichprobe zu sein fweight \\(\\Rightarrow\\) jede Beobachtung kommt mehrfach vor (Hochrechnungsfaktor) aweight \\(\\Rightarrow\\) jede Beobachtung im Datensatz ist eigentlich ein Gruppenmittelwert, der auf mehreren Beobachtungen basiert Weiterlesen Wir können Gewichtungen in Stata auf zwei Weisen anwenden: Zum einen können die Daten mit dem Befehl svyset als Surveydaten definiert werden. Hierbei können Variablen spezifiziert werden, die Informationen über das Survey-Design enthalten, wie die Stratifizierung und die anzuwendende Gewichtungsvariable. Anschließende Analyseverfahren werden mit dem Befehlspräfix svy durchgeführt. In diesem Beispiel: tabulate S1 // ungewichtet Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,074 50.34 50.34 weiblich | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 (Mit format(%10.3f) können wir die Darstellung als scientific notation (1.1e+04) umgehen) svyset _n [pweight=gew2018] svy: tabulate S1 , col count format(%10.3f) pweight: gew2018 VCE: linearized Single unit: missing Strata 1: &lt;one&gt; SU 1: &lt;observations&gt; FPC 1: &lt;zero&gt; (running tabulate on estimation sample) Number of strata = 1 Number of obs = 20,012 Number of PSUs = 20,012 Population size = 20,012.017 Design df = 20,011 ---------------------------------- Geschlech | t | count column ----------+----------------------- mÃ¤nnlich | 10941.888 0.547 weiblich | 9070.129 0.453 | Total | 20012.017 1.000 ---------------------------------- Key: count = weighted count column = column proportion Allerdings steht das svy-Präfix nicht für jeden Befehl zur Verfügung. Außerdem können kein weiteren Präfixe neben svy verwendet werden - beispielsweise by. Daher steht auch eine Alternative zur Verfügung, bei der wir die Gewichtung bei jedem Auswertungsschritt einzeln angeben. In unserem Beispiel also tabulate S1 [fweight=gew2018] may not use noninteger frequency weights r(401); Allerdings akzeptiert Stata bei Häufigkeitsgewichten frequency weights, keine Gewichtungswerte mit Nachkommastellen. Leider führt ein einfaches Auf- oder Abrunden führt aber häufig zu falschen Ergebnissen: tabulate S1 [fweight=round(gew2018)] // runden führt zu Abweichung - Vergleich mit svy: Ergebnis Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,524 55.44 55.44 weiblich | 8,458 44.56 100.00 ------------+----------------------------------- Total | 18,982 100.00 Eine mögliche Lösung dieser Problematik ist es, zunächst die Gewichtungsvariable mit einer hohen Zahl (bspw.100 000) zu multiplizieren und anschließend auf ganze Werte zu runden: tabulate S1 [fweight=round(gew2018*100 000)] Das führt zu korrekten Verteilungen. Allerdings ist für die Ergebnisse jedoch zu beachten, dass die zu Grunde liegende Fallzahl anschließend wieder korrigiert werden muss (also in diesem Beispiel durch 100 000 geteilt werden muss). Der eigentliche Zweck von fweight ist aber, die Auszählung hochzugewichten. In der Erwerbstätigenbefragung können wir das mit gew2018_hr17, dem Hochrechnungsfaktor auf dem Mikrozensus 2017 erreichen: tabulate S1 [fweight = round(gew2018_hr17)] Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 20,467,753 54.68 54.68 weiblich | 16,966,432 45.32 100.00 ------------+----------------------------------- Total | 37,434,185 100.00 Die Fallzahl ist also hier dann deutlich größer als die im Datensatz vorhandenen Fälle \\(\\Rightarrow\\) jeder Fall im Datensatz steht für eine Vielzahl an Fällen. 10.1.1 Übung Erstellen Sie eine Häufigkeitsauszählung der Ausbildungsabschlüsse (m1202) - zunächst ohne und dann mit Gewichtung. Verwenden Sie sowohl die pweights als auch die fweights an. 10.2 Import und Aufbereitung aus Excel 10.2.1 Datenimport aus Excel-Datei Unter file -&gt; import -&gt; excel spreadsheet können wir einen Excel-Import erstellen, den Befehl aus dem Ausgabefenster können wir dann kopieren: import excel &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB1\\Stata_Einführung_BIBB\\Rohdaten.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow case(lower) clear // oder: cd &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB1\\Stata_Einführung_BIBB\\&quot; import excel &quot;Rohdaten.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow case(lower) clear * Überblick gewinnen list browse id x1 x2 x3 x4 x5 1. 1 2 1 1 4 3 2. 2 1 -9 -9 2 5 3. 3 -4 1 1 5 . 4. 4 -4 -9 -9 2 1 5. 5 -4 -4 0 2 5 6. 6 -4 -9 1 5 2 7. 7 -4 1 -4 2 3 8. 8 1 -9 0 4 1 9. 9 1 -9 -9 5 3 10. 10 -4 -4 0 4 3 11. 11 1 -4 0 3 . 12. 12 -4 0 -9 3 2 13. 13 2 -4 1 4 2 14. 14 -4 -4 -9 4 5 15. 15 1 0 -9 2 5 Hier eine kleine (Fantasie-)Doku zum Datensatz: Variablenname Beschreibung Details id Befragten-Identifikationsnummer x1 Geschlecht 1 = Frau, 2 = Mann, -4 keine Angabe x2 Haustiere? 0 = nein, 1 = ja, -4 keine Angabe, -9 Datenfehler x3 Frühaufsteher? 0 = nein, 1 = ja, -4 keine Angabe, -9 Datenfehler x4 indx1 - 5er Likert-Skala: 1 = trifft überhaupt nicht zu 5 = tifft voll zu x5 indx2 - 5er Likert-Skala: 1 = tifft voll zu 5 = trifft überhaupt nicht zu 10.2.2 Variablen umbenennen: rename Dann benennen wir die Variablen in sprechendere Namen um rename alt neu: rename x1 gender rename x2 pets rename x3 earlybird rename x4 indx1 rename x5 indx5 id gender pets earlyb~d indx1 indx5 1. 1 2 1 1 4 3 2. 2 1 -9 -9 2 5 3. 3 -4 1 1 5 . 4. 4 -4 -9 -9 2 1 5. 5 -4 -4 0 2 5 6. 6 -4 -9 1 5 2 7. 7 -4 1 -4 2 3 8. 8 1 -9 0 4 1 9. 9 1 -9 -9 5 3 10. 10 -4 -4 0 4 3 11. 11 1 -4 0 3 . 12. 12 -4 0 -9 3 2 13. 13 2 -4 1 4 2 14. 14 -4 -4 -9 4 5 15. 15 1 0 -9 2 5 10.2.3 Variablenbeschreibung: label variable label variable gender &quot;Geschlecht&quot; label variable pets &quot;Haustierbesitz?&quot; label variable earlybird &quot;Frühaufsteher&quot; label variable indx1 &quot;index1&quot; label variable indx5 &quot;index2&quot; 10.2.4 Werte labeln label values Mit .buchstabe können wir fehlende Werte unterscheidbar halten, so können wir sowohl keine Angabe als auch Datenfehler als Missing überschreiben und trotzdem beide Varianten unterscheidbar halten: tab gender replace gender = .k if gender == -4 tab gender tab gender, m label define gend_lab 1 &quot;Frau&quot; 2 &quot;Mann&quot; .k &quot;keine Angabe&quot; lab val gender gend_lab tab gender tab gender, m (8 real changes made, 8 to missing) Geschlecht | Freq. Percent Cum. ------------+----------------------------------- 1 | 5 71.43 71.43 2 | 2 28.57 100.00 ------------+----------------------------------- Total | 7 100.00 Geschlecht | Freq. Percent Cum. -------------+----------------------------------- Frau | 5 33.33 33.33 Mann | 2 13.33 46.67 keine Angabe | 8 53.33 100.00 -------------+----------------------------------- Total | 15 100.00 Für die weiteren Variablen können wir ähnlich vorgehen: lab def dummy_lab 0 &quot;Nein&quot; 1 &quot;Ja&quot; .k &quot;keine Angabe&quot; .d &quot;Datenfehler&quot; lab val earlybird dummy_lab tab earlybird recode earlybird (-9=.d) (-4=.k) * oder: replace earlybird = .k if earlybird == -4 replace earlybird = .d if earlybird == -9 tab earlybird,m (earlybird: 7 changes made) Frühaufstehe | r | Freq. Percent Cum. -------------+----------------------------------- Nein | 4 26.67 26.67 Ja | 4 26.67 53.33 Datenfehler | 6 40.00 93.33 keine Angabe | 1 6.67 100.00 -------------+----------------------------------- Total | 15 100.00 10.2.5 Fortgeschrittene Programmierung: foreach-Schleife help foreach zeigt alle Möglichkeiten für eine foreach-Schleife. Da wir hier Variablen bearbeiten möchten, ist foreach v of varlist die richtige Option. Siehe hier die Erklärungen zu varlist, numlist usw. foreach v of varlist earlybird pets { replace `v&#39; = .k if `v&#39; == -4 replace `v&#39; = .d if `v&#39; == -9 lab val `v&#39; dummy_lab } // oder foreach v of varlist earlybird pets { recode `v&#39; (-9=.d) (-4=.k) lab val `v&#39; dummy_lab } (earlybird: 7 changes made) (pets: 10 changes made) 10.2.6 Index bilden Um jetzt einen Index aus indx1 und indx2 zu bilden, müssen wir zuerst eine der beiden umdrehen. Zur Erinnerung: Variablenname Beschreibung Details x4 indx1 - 5er Likert-Skala: 1 = trifft überhaupt nicht zu 5 = tifft voll zu x5 indx2 - 5er Likert-Skala: 1 = tifft voll zu 5 = trifft überhaupt nicht zu Hier drehen wir also indx1 um: gen indx1_rev = 6 - indx1 // (max+1) - indexwert list indx*, abbreviate(10) | indx1 indx2 indx1_rev | |---------------------------| 1. | 4 3 2 | 2. | 2 5 4 | 3. | 5 . 1 | 4. | 2 1 4 | 5. | 2 5 4 | |---------------------------| 6. | 5 2 1 | 7. | 2 3 4 | 8. | 4 1 2 | 9. | 5 3 1 | 10. | 4 3 2 | |---------------------------| 11. | 3 . 3 | 12. | 3 2 3 | 13. | 4 2 2 | 14. | 4 5 2 | 15. | 2 5 4 | +---------------------------+ Damit können wir jetzt zum eigentlichen Index kommen. Die einfachste Möglichkeit ist einfach mit gen gen index = (indx1_rev + indx2)/2 // !missings list ind*, abbreviate(15) (2 missing values generated) +-----------------------------------+ | indx1 indx2 indx1_rev index | |-----------------------------------| 1. | 4 3 2 2.5 | 2. | 2 5 4 4.5 | 3. | 5 . 1 . | 4. | 2 1 4 2.5 | 5. | 2 5 4 4.5 | |-----------------------------------| 6. | 5 2 1 1.5 | 7. | 2 3 4 3.5 | 8. | 4 1 2 1.5 | 9. | 5 3 1 2 | 10. | 4 3 2 2.5 | |-----------------------------------| 11. | 3 . 3 . | 12. | 3 2 3 2.5 | 13. | 4 2 2 2 | 14. | 4 5 2 3.5 | 15. | 2 5 4 4.5 | +-----------------------------------+ Hier werden also in allen Zeilen, in denen (mind.) ein Wert Missing, also ., ist im Summenindex auch ein Missing ausgegeben. Wollen wir das nicht, können wir rowmean() aus egen verwenden: egen indexb = rowmean(indx1_rev indx2) list ind*, abbreviate(15) | indx1 indx2 indx1_rev index indexb | |--------------------------------------------| 1. | 4 3 2 2.5 2.5 | 2. | 2 5 4 4.5 4.5 | 3. | 5 . 1 . 1 | 4. | 2 1 4 2.5 2.5 | 5. | 2 5 4 4.5 4.5 | |--------------------------------------------| 6. | 5 2 1 1.5 1.5 | 7. | 2 3 4 3.5 3.5 | 8. | 4 1 2 1.5 1.5 | 9. | 5 3 1 2 2 | 10. | 4 3 2 2.5 2.5 | |--------------------------------------------| 11. | 3 . 3 . 3 | 12. | 3 2 3 2.5 2.5 | 13. | 4 2 2 2 2 | 14. | 4 5 2 3.5 3.5 | 15. | 2 5 4 4.5 4.5 | +--------------------------------------------+ Häufig ist aber wahrscheinlich eine Zwischenlösung das Ziel, d.h. wir wollen vllt rowmean() nur anwenden, wenn eine Mindestanzahl an gültigen Werten vorliegt oder eine Höchstzahl an fehlenden Werten. Die Zahl der Missings in bestimmten Variablen können wir mit rowmiss() berechnen, die Zahl der gültigen Werte mit rownonmiss(). Anschließend können wir mit if eine entsprechende Einschränkung setzen: egen nonmiss = rownonmiss(indx1_rev indx2) egen miss = rowmiss(indx1_rev indx2) egen indexc = rowmean(indx1_rev indx2) if miss == 2 list ind* *miss, abbreviate(15) | indx1 indx2 indx1_rev index indexb indexc nonmiss miss | |----------------------------------------------------------------------| 1. | 4 3 2 2.5 2.5 2.5 2 0 | 2. | 2 5 4 4.5 4.5 4.5 2 0 | 3. | 5 . 1 . 1 1 1 1 | 4. | 2 1 4 2.5 2.5 2.5 2 0 | 5. | 2 5 4 4.5 4.5 4.5 2 0 | |----------------------------------------------------------------------| 6. | 5 2 1 1.5 1.5 1.5 2 0 | 7. | 2 3 4 3.5 3.5 3.5 2 0 | 8. | 4 1 2 1.5 1.5 1.5 2 0 | 9. | 5 3 1 2 2 2 2 0 | 10. | 4 3 2 2.5 2.5 2.5 2 0 | |----------------------------------------------------------------------| 11. | 3 . 3 . 3 3 1 1 | 12. | 3 2 3 2.5 2.5 2.5 2 0 | 13. | 4 2 2 2 2 2 2 0 | 14. | 4 5 2 3.5 3.5 3.5 2 0 | 15. | 2 5 4 4.5 4.5 4.5 2 0 | +----------------------------------------------------------------------+ 10.2.7 exportieren compress // variablen auf minimale speichergröße bringen save &quot;Datensatz_ready.dta&quot;, replace Dieser Datensatz kann mit use geladen werden. 10.3 adopath Mit adopath können wir die Ordner anzeigen, wo die ados liegen. Mit which können wir den Speicherort eines ado ansehen: which mdesc c:\\ado\\plus\\m\\mdesc.ado *! mdesc Version 2.1 dan_blanchette@unc.edu 25Aug2011 *! Rose Anne Medeiros | Dan Blanchette *! Department of Sociology, Rice Univ | the carolina population center, unc-ch Mit adopath ++ PFAD können wir ado aus zusätzlichen Ordner verwenden: adopath ++ &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB1\\Stata_Einführung_BIBB/u&quot; 10.4 log file Mit log-Files können wir alles mitprotokollieren, was im Outputfenster passiert. Wir starten ein log-File mit log using dateiname. Ab dann wird alles in dieser Datei mitgeschrieben, was wir uns im Outputfenster anzeigen lassen: log using &quot;C:\\Pfad\\zum\\Ordner/log/logfile.txt&quot;, text replace // mit replace wird die Datei ggf überschrieben * ------------------------------------------------ * * Alter, Bildung, Geschlecht in der ETB 2018 * ------------------------------------------------ * glo data &quot;D:\\Datenspeicher\\BIBB_BAuA/&quot; use &quot;${data}/BIBBBAuA_2018_suf1.0.dta&quot;, clear mvdecode zpalter, mv(9999) // dieses log enthält auch kommentare mvdecode m1202,mv(-1) // noch einen * ------------------------ * * Auswertung * ------------------------ * tab m1202 S1 su zpalter log close 10.5 Beobachtungen markieren mit gen &amp; if Die Kombination aus gen und if hilft uns, wenn wir eine Variable nur für einige Zeilen erstellen wollen. Das hilft insbesondere, wenn wir bestimmte Beobachtungen markieren wollen. Beispielsweise Frauen (S1 = 1), die einer Nebentätigkeit (nt = 1) nachgehen: gen nt_frauen = 1 if S1 == 1 &amp; nt == 1 (19,136 missing values generated) Nur wenn beide Bedingungen zutreffen, wird unter nt_frauen eine 1 abgelegt: list S1 nt nt_frauen in 19671/19675, clean noobs abb(12) S1 nt nt_frauen weiblich keine Ne . mÃ¤nnlic mindeste 1 weiblich keine Ne . mÃ¤nnlic mindeste 1 weiblich keine Ne . In der alltäglichen Arbeit hilft das manchmal, wenn man spezielle Fälle immer wieder aufrufen möchte und nicht immer die ausgeschriebenen if-Bedingungen verwenden möchte. 10.6 macros Macros ist die Sammelbezeichung für globals und locals in Stata. Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen. Definiert werden sie durch globalinhalt oder localinhalt - oft mit glo und loc als Abkürzungen. globals können dann mit $globalname/${globalname} aufgerufen werden, locals mit `localname' - ganz einfach bspw. mit dis[play]: glo x 1 dis ${x} 1 loc y 2 dis `y&#39; 2 Der Unterschied besteht vor allem darin, dass local macros lokal für ein spezifisches Programm verfügbar sind, globale macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind. Ein macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden: glo pfad &quot;D:\\Projekt\\daten\\BIBB_BAuA&quot; // wo liegt der Datensatz? dis &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot; D:\\Projekt\\daten\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Wir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden: glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; Micha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
