[["index.html", "Stata Einführung am BIBB Herzlich Willkommen", " Stata Einführung am BIBB Andreas Filser 2022-01-17 Herzlich Willkommen Hier entsteht das Begleitskript für die Stata-Weiterbildung am BIBB von Andreas Filser am 15.12.2021. "],["stata.html", "1 Überblick zu Stata 1.1 Taschenrechner 1.2 Darstellung in diesem Skript 1.3 DoFile Editor 1.4 Datensätze laden 1.5 Überblicksbefehle 1.6 Übungen 1 1.7 Profi-Übungen 1 1.8 Anhang 1", " 1 Überblick zu Stata Hier sehen wir die Startansicht von Stata: Figure 1.1: Startansicht Stata16 Die Standardansicht von Stata besteht aus mehreren Fenstern: Kommandos/Befehle Ergebnisse Variablenübersicht Übersicht zu den geladenen Daten Befehlshistorie 1.1 Taschenrechner In das Befehlsfeld (1) können wir Kommandos eingeben, z.B. eine Berechnung durchführen. Dazu geben wir zunächst den Befehl display und dann die gewünschte Rechnung ein und drücken dann Enter. Der Befehl wird dann im Ergebnisfenster gespiegelt und darunter das Ergebnis ausgegeben: Wir können display auch mit dis abkürzen. 1.2 Darstellung in diesem Skript Eingaben und Ergebnisse werden im weiteren Skript so dargestellt: display 3 + 12 | is not a valid command name r(199); 15 display sqrt(9) | is not a valid command name r(199); 3 1.3 DoFile Editor Zwar funktioniert die direkte Eingabe in das Befehlsfeld, allerdings werden für Auswertungen sehr viel längere und komplexere Befehle und längere Befehlsfolgen verwendet. Für solche Anwendungen werden in Stata sog. DoFiles angelegt. Darin können Befehle entworfen und für eine spätere Verwendung abgespeichert werden. Um ein DoFile zu öffnen geben wir entweder doedit in das Befehlsfeld ein oder klicken auf das Feld New Do-file-Editor rechts oben: Es öffnet sich ein neues Fenster: In diesem sog. Do-File-Editor können wir Befehle entwerfen. Wenn wir diese dann durchführen möchten, markieren wir die entsprechenden Zeilen und drücken STRG + D. Die ausgeführten Befehle werden wieder im Ergebnisfenster gespiegelt und jeweils darunter die Ergebnisse angezeigt: Das DoFile können wir speichern, um es später wieder aufzurufen. Wichtig ist dabei, der gespeicherten Datei die Endung .do zu geben, also zum Beispiel 01_Einstieg.do. Diese DoFiles können dann einfach ausgetauscht werden, um später daran weiter zu arbeiten oder Analysen für Dritte nachvollziehbar zu machen. 1.4 Datensätze laden Das ist aber alles soweit sehr unspektulär - es gibt schönere und günstigere Taschenrechner als Stata. Die eigentliche Stärke von Stata ist die Analyse von Datensätzen. Diese müssen zunächst eingelesen werden. Im einfachsten Fall liegen die Daten als Stata-Datensatz (mit der Endung .dta) vor und wir können die Daten wie folgt einlesen: cd &quot;C:/Kurse/Stata_BIBB/data/&quot; use &quot;BIBBBAuA_2018_suf1.0.dta&quot; Der Einlesevorgang besteht also aus zwei Befehlen: zuerst geben wir cd den Pfad an, unter welchem der einzulesende Datensatz zu finden ist. Natürlich hängt der Dateipfad aber ganz davon ab, wo Sie den Datensatz gespeichert haben, hier ist es C:/Kurse/Stata_BIBB/data/: Um den Pfad des Ordners herauszufinden, klicken Sie bei Windows in die obere Adresszeile im Explorerfenster: In iOS (Mac) finden Sie den Pfad, indem Sie einmal mit der rechten Maustaste auf die Datei klicken und dann die ALT-Taste gedrückt halten. Dann sollte die Option als Pfadname kopieren erscheinen. Youtube Anleitung Hat das funktioniert? Wir haben zwei Möglichkeiten zu das aktuelle Arbeitsverzeichnis überprüfen: wir sehen das aktuelle Arbeitsverzeichnis im Stata-Fenster links unten oder wir geben pwd ein: Wir können diese beiden Schritte natürlich auch einfach kombinieren und den gesamten Pfad nach use angeben: use &quot;C:/Kurse/Stata_BIBB/data/BIBBBAuA_2018_suf1.0.dta&quot; Wenn das funktioniert hat, dann sehen wir im Fenster rechts eine Variablenübersicht: 1.5 Überblicksbefehle Für eine erste Annäherung an die Daten helfen uns drei Überblicksbefehle: browse, describe und list. Zur Erinnerung: wir haben den Datensatz geladen: cd &quot;C:/Users/Andreas/Dokumente/Statistik/&quot; use &quot;BIBBBAuA_2018_suf1.0.dta&quot; 1.5.1 describe Mit describe, short bekommen wir einen Überblick zu den eingelesenen Daten: describe, short | is not a valid command name r(199); Contains data from D:\\Datenspeicher\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta obs: 20,012 vars: 683 11 Feb 2020 12:51 Sorted by: intnr Hier wurde also ein Datensatz geladen, welcher 20012 Fälle/Zeilen (obs) und 683 Variablen/Spalten (vars) enthält. (Wir können den Befehl auch als d,s abkürzen) Wir können den describe Befehl auch nutzen, um Informationen zu einer Variable zu erhalten. Dazu hängen wir einfach eine oder mehrere Variablen an describe an: describe F209 | is not a valid command name r(199); storage display value variable name type format label variable label -------------------------------------------------------------------------------- F209 byte %8.0g F209 Liegt Ihre Arbeitszeit normalerweise zwischen 7 und 19 Uhr? Hier sehen wir also in der ersten Spalte nochmal den vollständigen Variablennamen, den Variablentypen (storage type - mehr dazu hier) sowie - falls vorhanden - eine Beschreibung der Variable (variable label) sowie (ggf.) die Labels für Ausprägungen der Variable (value label). Letztere können wir mit Hilfe von labelbook aufrufen (mehr zu Labels später): labelbook F209 | is not a valid command name r(199); -------------------------------------------------------------------------------- value label F209 -------------------------------------------------------------------------------- values labels range: [1,9] string length: [2,12] N: 3 unique at full length: yes gaps: yes unique at length 12: yes missing .*: 0 null string: no leading/trailing blanks: no numeric -&gt; numeric: no definition 1 ja 2 nein 9 keine Angabe variables: F209 Wir können auch alle Variablen aufrufen, die mit F209 beginnen, indem wir einen * einsetzen: describe F209* | is not a valid command name r(199); storage display value variable name type format label variable label -------------------------------------------------------------------------------- F209 byte %8.0g F209 Liegt Ihre Arbeitszeit normalerweise zwischen 7 und 19 Uhr? F209_01 byte %8.0g F209_01 Arbeiten Sie in Schichtarbeit? 1.5.2 browse Mit browse bekommen wir eine Ansicht des Datensatzes: browse Wenn wir nur einige Variablen betrachten möchten, hängen wir diese einfach browse an: browse intnr Bula gkpol Stib zpalter Hier bekommen aber immer die gelabelte Ansicht - allerdings stehen dahinter Zahlenwerte. Die Labels helfen uns, deren Bedeutung zu verstehen. Wenn wir aber wie in den nächsten Tagen auch mit den Daten arbeiten wollen, dann beziehen sich diese Operationen immer auf die dahinterstehenden Zahlenwerte. Diese bekommen wir mit der Option nolabel (oft auch einfach als nol abgekürzt): browse intnr Bula gkpol Stib zpalter , nolabel 1.5.3 list browse eignet sich vor allem für größere Übersichten. Wenn wir nur einige wenige Fälle betrachten möchten, dann ist list eine gute Alternative, da der Output hier gleich im Ergebnisfenster (2) angezeigt wird. Die Funktionsweise von list ähnelt sich im Prinzip der von browse. Mit dem Zusatz in 1/5 können wir die ersten 5 Zeilen anzeigen lassen (ansonsten würden alle 20012 Fälle angezeigt!): list intnr Bula gkpol Stib zpalter in 1/5 | intnr Bula gkpol Stib zpalter | |-----------------------------------------------| 1. | 260 Berlin 500.000 Selbstst 41 | 2. | 361 Berlin 500.000 Angestel 51 | 3. | 491 Berlin 500.000 Arbeiter 49 | 4. | 690 Berlin 500.000 Beamter 63 | 5. | 919 Berlin 500.000 Angestel 41 | |-----------------------------------------------| Auch hier können wir wie bei browse die Zahlenwerte ohne die Labels anzeigen lassen, indem wir , nolabel anhängen: list intnr Bula gkpol Stib zpalter in 1/5, nolabel | intnr Bula gkpol Stib zpalter | |---------------------------------------| 1. | 260 11 7 4 41 | 2. | 361 11 7 2 51 | 3. | 491 11 7 1 49 | 4. | 690 11 7 3 63 | 5. | 919 11 7 2 41 | |---------------------------------------| 1.5.4 lookfor All diese Befehle setzen aber voraus, dass wir wissen, unter welchem Variablennamen die interessierende Information abgelegt wurde. Mit lookfor \"stichwort\" können wir den Datensatz nach einem Stichwort durchsuchen: lookfor &quot;Englisch&quot; | is not a valid command name r(199); storage display value variable name type format label variable label -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- F403_10 byte %8.0g F403_10 BenÃ¶tigte Kenntnisse: Grund- oder Fachkenntnisse in Englisch? F404_01 byte %8.0g F404_01 Wie gut mÃ¼ssen Sie Englisch beherrschen? Sicher in Wort F404_02 byte %8.0g F404_02 Wie gut mÃ¼ssen Sie Englisch beherrschen? Sicher in Schrift F404_03 byte %8.0g F404_03 Wie gut mÃ¼ssen Sie Englisch beherrschen? Verhandlungssicher F404_09 byte %8.0g F404_09 Wie gut mÃ¼ssen Sie Englisch beherrschen? Keine Angabe F1606_02 byte %8.0g F1606_02 Muttersprache: Englisch Alternativ können wir auch in der Variablenübersicht mit Hilfe des Suchfelds nach Variablen suchen: 1.6 Übungen 1 Öffnen Sie Stata und öffnen Sie den DoFile Editor Führen Sie folgende (oder beliebige andere) Taschenrechneraufgaben mit Stata durch: 2 * 4 2 / 8 2 ^ 2 // (Potenz) sqrt(9) // (Wurzel) Lesen Sie die Erwerbstätigenbefragung 2018 in Stata ein. Folgende Schritte helfen Ihnen dabei: In welchem Arbeitsverzeichnis befindet sich Stata aktuell? Wo können Sie das erkennen? In welchem Ordner haben Sie den Erwerbstätigenbefragung Datensatz abgelegt? Navigieren Sie Stata mit cd in diesen Ordner, in dem der Datensatz abgelegt ist! Lesen Sie den Datensatz mit use ein Nutzen Sie describe und browse, um sich einen Überblick über den Datensatz zu verschaffen. Wie viele Variablen und wie viele Fälle enthält der Datensatz? Unter welchem Variablennamen ist die Information abgelegt, ob der*die Befrage Kinder hat? Nutzen Sie lookfor oder die Suchfunktion im Variablenfenster. Lassen Sie sich die Informationen zur Variable mit describe anzeigen. Wie heißt das angehängte Label? Inspizieren Sie es mit labelbook. Lassen Sie sich diese Variable im Datenexplorer mit browse anzeigen. Lassen Sie sich diese Variable mit den Zahlencodes (nolabel) anstatt der labels anzeigen. 1.7 Profi-Übungen 1 Für alle, die noch etwas mehr machen möchten: Im zip-Ordner finden Sie auch eine SPSS-Version (.sav-Datei) der Erwerbstätigenbefragung 2018. Lesen Sie diese Dateiversion in Stata ein! (Siehe weitere Anmerkungen) 1.8 Anhang 1 1.8.1 Variablentypen In Stata gibt es zwei Variablentypen: Zahlenvariablentypen: byte,int,long,float,double - der Unterschiede zwischen diesen Variablentypen besteht vor allem in der Spannbreite der möglichen Werte: während byte Werte zwischen -127 und 100 annehmen kann, können in long zwischen -2,147,483,647 2,147,483,620 (Stata verwaltet diese Typen in der Regel automatisch - für weitere Hinweise help data_types) Textvariablen, sog. strings strXX - wobei XX die Zahl der (maximal) verwendeten Zeichen angibt In der BIBB/BAuA Erwerbstätigenbefragung 2018 sind nur Zahlenvariablen enthalten. 1.8.2 import anderer Dateiformate Häufig liegen Datensätze nicht im .dta-Format vor, sondern beispielsweise als Excel-Tabelle (.xslx oder .xls), SPSS-Datei (.sav) oder als .csv-Datei. Hierfür stehen alternative Importbefehle zur Verfügung: import excel für Excel Tabellen import spss für SPSS-Dateien import delimited für csv-Dateien Hier empfiehlt sich ein Blick in das Auswahlmenü unter File &gt; Import: Nach Klick auf das entsprechende Dateiformat öffnet sich ein Dialogfenster, in das die gewünschten Optionen eingetragen werden können. Sind alle Optionen wie gewünscht gesetzt, gibt es unten gibt es die Möglichkeit, den so zusammengestellten Befehl nicht nur durchzuführen, sondern auch zu kopieren (um ihn beispielsweise in ein DoFile einzufügen): "],["stata2.html", "2 Arbeiten mit Datensätzen in Stata 2.1 Befehlsstruktur 2.2 Auszählen &amp; Überblick erhalten 2.3 Fehlende Werte 2.4 Zwei Variablen, eine Tabelle: Kontingenztabellen 2.5 metrische Variablen 2.6 Nochmal von vorne: Daten neu laden 2.7 Speichern 2.8 Übungen 2", " 2 Arbeiten mit Datensätzen in Stata Nachdem wir uns in Stata etwas umgesehen haben, können wir uns jetzt dem eigentlichen Arbeiten mit Datensätzen zuwenden. cd .... use &quot;BIBBBAuA_2018_suf1.0.dta&quot; 2.1 Befehlsstruktur Ganz nebenbei haben wir in Kapitel 1 bereits die ersten Stata-Befehle verwendet. Bevor wir jetzt aber tiefer einsteigen nochmal einmal allgemein: Die grundsätzliche Struktur von Stata-Kommandos ist immer befehl variable, optionen. Zunächst geben wir also immer an, was passieren soll - bisher war das eben zum Beispiel eine Auflistung (list) einiger Variable für einige Zeilen: list intnr Bula gkpol Stib zpalter in 11/12 | intnr Bula gkpol Stib zpalter | |--------------------------------------------------| 11. | 1562 Berlin 500.000 Angestel 31 | 12. | 1955 Berlin 500.000 Angestel 58 | Mit Hilfe von Optionen können wir die Ausgabe verändern: bspw. hatten wir schong gesehen, dass durch das Anhängen der Option nolabel die rohen Zahlenwerte statt der beschrifteten Ausprägungen angezeigt werden: list intnr Bula gkpol Stib zpalter in 11/12, nolabel | intnr Bula gkpol Stib zpalter | |---------------------------------------| 11. | 1562 11 7 2 31 | 12. | 1955 11 7 2 58 | 2.1.1 Zeilenumbrüche Kommandos in Stata sind zeilenbasiert. D.h. alles was zu einem Kommando gehört, muss in der gleichen Zeile stehen. Umgekehrt wird auch alles, was in einer Zeile steht als Teil des Kommandos verstanden. Daher werden bei list intnr Bula gkpol Stib zpalter in 11/15 auch nicht nur intnr sondern auch die anderen Variablen angezeigt. Das funktioniert nicht: list intnr Bula gkpol Stib zpalter in 11/12 (Hier werden erstmal 20012 Zeilen von intnr und Bula ausgegeben) command gkpol is unrecognized r(199); Mit /// können wir Zeilen verknüpfen: list intnr Bula /// gkpol Stib zpalter in 11/12 | intnr Bula gkpol Stib zpalter | |---------------------------------------| 11. | 1562 11 7 2 31 | 12. | 1955 11 7 2 58 | 2.1.2 Kommentare Außerdem können wir mit // Kommentare in unsere DoFiles einfügen. // blendet alles folgende am Ende der Zeile aus: list intnr Bula gkpol Stib zpalter in 11/15 // dies ist ein kommentar /// kann auch zum Kommentieren verwendet werden: list intnr Bula /// hier kann ein kommentar stehen gkpol Stib zpalter in 11/15 // hier geht es weiter, aber der Befehl endet mit dieser Zeile Alternativ können wir mit * eine komplette Zeile deaktivieren: *list intnr Bula gkpol Stib zpalter in 11/15 So wird der Befehl ignoriert. 2.2 Auszählen &amp; Überblick erhalten Mit tabulate bekommen wir eine Auszählung der Ausprägungen einer Variable, indem wir einfach den Variablennamen anhängen (kann auch mit tab m1202 abgekürzt werden): tabulate m1202 | is not a valid command name r(199); HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- keine Angabe | 45 0.22 0.22 Ohne Berufsabschluss | 1,091 5.45 5.68 duale o. schulische Berufsausbildung/ei | 9,297 46.46 52.13 Aufstiegsfortbildung (Meister, Technike | 1,725 8.62 60.75 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.25 100.00 ----------------------------------------+----------------------------------- Total | 20,012 100.00 In der ersten Spalte werden die verschiedenen Ausprägungen aufgelistet, in der zweiten Spalte finden wir dann die absoluten Häufigkeiten (Freq.) der jeweiligen Ausprägung, in der dritten Spalte finden wir die relativen Häufigkeiten (Percent) und in der vierten Spalte (Cum.) finden wir die kumulierten relativen Häufigkeiten: Freq.: der Datensatz enthält 1,091 Befragte ohne Berufsabschluss (absolute Häufigkeit) Percent: 5,45% der im Datensatz enthaltenen Befragte haben keinen Berufsabschluss (relative Häufigkeit) Cum: 5,68% der im Datensatz enthaltenen Befragte haben keinen Berufsabschluss oder machten keine Angabe (kumulierte relative Häufigkeit) Mit nolabel die dahinterliegenden Zahlenwerte anzeigen lassen: tabulate m1202, nolabel | is not a valid command name r(199); HÃ¶chster | Ausbildungs | abschluss | Freq. Percent Cum. ------------+----------------------------------- -1 | 45 0.22 0.22 1 | 1,091 5.45 5.68 2 | 9,297 46.46 52.13 3 | 1,725 8.62 60.75 4 | 7,854 39.25 100.00 ------------+----------------------------------- Total | 20,012 100.00 Mit Hilfe von d und labelbook können wir uns die Labels ausgeben lassen: d m1202 labelbook M1202 | is not a valid command name r(199); storage display value variable name type format label variable label -------------------------------------------------------------------------------- m1202 byte %8.0g M1202 HÃ¶chster Ausbildungsabschluss -------------------------------------------------------------------------------- value label M1202 -------------------------------------------------------------------------------- values labels range: [-1,4] string length: [12,57] N: 5 unique at full length: yes gaps: yes unique at length 12: yes missing .*: 0 null string: no leading/trailing blanks: no numeric -&gt; numeric: no definition -1 keine Angabe 1 Ohne Berufsabschluss 2 duale o. schulische Berufsausbildung/einf.,mittl. Beamte 3 Aufstiegsfortbildung (Meister, Techniker, kfm. AFB u.Ã¤.) 4 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶here Beamte variables: m1202 Für Fälle ohne gültige Angaben zum höchsten Ausbildungsabschluss wurde also -1 als Wert in m1202 abgelegt. Stata berücksichtigt diese Tatsache aber noch nicht und summiert bspw. die kumulierten relativen Häufigkeiten auch über die fehlenden Angaben auf. Um das zu ändern, müssen wir -1 als missing value überschreiben. 2.3 Fehlende Werte Fehlende Werte, sog. missing values werden in Stata mit . abgelegt und werden dann für die weiteren Berechnungen ausgeschlossen. Um also -1 als . zu überschreiben, können wir zB auf den replace Befehl zurückgreifen: tabulate m1202 replace m1202 = . if m1202 == -1 tabulate m1202 | is not a valid command name r(199); HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- keine Angabe | 45 0.22 0.22 Ohne Berufsabschluss | 1,091 5.45 5.68 duale o. schulische Berufsausbildung/ei | 9,297 46.46 52.13 Aufstiegsfortbildung (Meister, Technike | 1,725 8.62 60.75 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.25 100.00 ----------------------------------------+----------------------------------- Total | 20,012 100.00 (45 real changes made, 45 to missing) HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- Ohne Berufsabschluss | 1,091 5.46 5.46 duale o. schulische Berufsausbildung/ei | 9,297 46.56 52.03 Aufstiegsfortbildung (Meister, Technike | 1,725 8.64 60.67 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.33 100.00 ----------------------------------------+----------------------------------- Total | 19,967 100.00 Wir bekommen von Stata mitgeteilt, dass wir 45 Beobachtungen verändert und auf missing gesetzt haben. Im folgenden tabulate werden diese fehlenden Werte dann ignoriert. Ein Spezialbefehl für die Überschreibung von bestimmten Werten ist mvdecode. Mit mvdecode können wir -1 in mehreren Variablen gleichzeitig als missing überschreiben. Zum Beispiel in F100_kldb2010_BOF, F1609_kldb2010_BOF und F1610_kldb2010_BOF: mvdecode F100_kldb2010_BOF F1609_kldb2010_BOF F1610_kldb2010_BOF, mv(-1) | is not a valid command name r(199); F100_k~0_BOF: 64 missing values generated F1609_~0_BOF: 805 missing values generated F1610_~0_BOF: 176 missing values generated (F1609_kldb2010_BOF enthält das BIBB-Berufsoberfeld f. Erwerbsberuf, KldB2010, F1609_kldb2010_BOF die selbe Information für den Vater und F1610_kldb2010_BOF für die Mutter der*des Befragten.) Wir können auch mit / einen Wertebereich angeben, der als Missing definiert werden soll, zB. für das Bundesland der Betriebsstätte: mvdecode F100_wib1, mv(-4/-1) | is not a valid command name r(199); F100_wib1: 104 missing values generated Mit mdesc bekommen wir eine Auszählung zu fehlenden Werten. mdesc ist allerdings kein Standard-Stata-Befehl, sondern muss extra installiert werden. Das ist allerdings kein größerer Aufwand: ssc install mdesc Anschließend können wir mit mdesc die Zahl der missings in zpalter, S2_j, F510 und F511_j ausgeben lassen: mdesc m1202 F100_kldb2010_BOF F1609_kldb2010_BOF F1610_kldb2010_BOF F100_wib1 | is not a valid command name r(199); command mdesc is unrecognized r(199); end of do-file r(199); Hinweis: welche Angaben als Missing definiert werden sollen, ist teilweise von der Frage ab, die beantwortet werden soll. Bspw. wurden oben alle uneindeutigen Angaben in F233 zum Bundesland der Betriebsstätte als missing codiert. Je nach Fragestellung ist das eine mehr oder weniger gute Idee. In tabulate können wir mit der Option , missing die fehlenden Werte anzeigen lassen: tabulate m1202, missing | is not a valid command name r(199); HÃ¶chster Ausbildungsabschluss | Freq. Percent Cum. ----------------------------------------+----------------------------------- Ohne Berufsabschluss | 1,091 5.45 5.45 duale o. schulische Berufsausbildung/ei | 9,297 46.46 51.91 Aufstiegsfortbildung (Meister, Technike | 1,725 8.62 60.53 Fachhochschule, UniversitÃ¤t/ geh., hÃ¶he | 7,854 39.25 99.78 . | 45 0.22 100.00 ----------------------------------------+----------------------------------- Total | 20,012 100.00 2.4 Zwei Variablen, eine Tabelle: Kontingenztabellen Neben der einfachen Verteilung der Variable interessiert uns aber meistens, ob sich die Verteilung zwischen Gruppen unterscheidet. Hierfür sind Kontingenztabellen ein wichtiges und sehr häuifg verwendetes Werkzeug. Aus Kontingenztabellen erfahren wir, wie häufig Merkmalskombinationen auftreten. Auch für Kontingenztabellen können wir ebenfalls tabulate verwenden. Zum Beispiel können wir uns eine Tabelle anzeigen lassen, die uns die Ausbildungsabschlüsse getrennt nach Geschlechtern zeigt. Da die Variable S1 keine Missings hat, können wir direkt loslegen. Für die Kontingenztabelle geben wir dann nach tabulate die beiden Variablen an, welche die Zeilen und Spalten definieren: tabulate m1202 S1 | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 594 497 | 1,091 duale o. schulische B | 4,371 4,926 | 9,297 Aufstiegsfortbildung | 1,073 652 | 1,725 Fachhochschule, Unive | 4,015 3,839 | 7,854 ----------------------+----------------------+---------- Total | 10,053 9,914 | 19,967 Wir erkennen aus dieser Tabelle beispielsweise, dass 1,073 Männer und 652 Frauen eine Aufstiegsfortbildung besitzen. 2.4.1 In Prozent: Relative Häufigkeiten Auch hier können wir uns die relativen Häufigkeiten anzeigen lassen, indem wir die Option ,cell anwenden. Um die Tabelle übersichtlich zu halten, können wir mit nofreq die absoluten Häufigkeiten ausblenden (ansonsten werden die absoluten und die relativen Häufigkeiten ausgegeben). tabulate m1202 S1, cell nofreq | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 2.97 2.49 | 5.46 duale o. schulische B | 21.89 24.67 | 46.56 Aufstiegsfortbildung | 5.37 3.27 | 8.64 Fachhochschule, Unive | 20.11 19.23 | 39.33 ----------------------+----------------------+---------- Total | 50.35 49.65 | 100.00 Die hier dargestellten relativen Häufigkeiten beziehen sich jeweils auf die Gesamtzahl der Befragten. Formal dargestellt wird also für die Kombination Aufstiegsfortbildung und Geschlecht = weiblich die Anzahl der Frauen mit Aufstiegsfortbildung durch die Anzahl aller Befragten geteilt: \\(\\frac{\\text{Anzahl der Frauen mit Aufstiegsfortbildung}}{\\text{Gesamtzahl der Befragten}}\\) - Wir können also aus dieser Tabelle ablesen, dass 1,27% aller Befragten weiblich sind und eine Aufstiegsfortbildung haben. Für den Vergleich zwischen Gruppen sind aber in der Regel die bedingten relativen Häufigkeiten informativer. Hier kommt es jetzt darauf an, welche der beiden Variablen die Gruppen definieren sollen und welche Variable wir untersuchen möchten: 2.4.2 pro Gruppe 1: Zeilenprozente Wir können diese Tabelle auch mit Zeilenprozenten anzeigen lassen, indem wir die Option row verwenden: tabulate m1202 S1, row nofreq | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 54.45 45.55 | 100.00 duale o. schulische B | 47.02 52.98 | 100.00 Aufstiegsfortbildung | 62.20 37.80 | 100.00 Fachhochschule, Unive | 51.12 48.88 | 100.00 ----------------------+----------------------+---------- Total | 50.35 49.65 | 100.00 Achtung! Damit ändert sich jeweils die Interpretation der Tabelle! Wir ändern durch row die Bezugsgröße oder formal ausgedrückt den Nenner: Für die Zeilenprozente werden die Werte in Bezug zu den Zeilensummen gesetzt. Also wird die Anzahl der ledigen 35-59 Jährigen ins Verhältnis zur Gesamtzahl der 1x/Woche Internet nutzenden Befragten gesetzt: \\(\\frac{\\text{Anzahl der Frauen mit Aufstiegsfortbildung}}{\\text{Anzahl der Befragten mit Aufstiegsfortbildung}}\\) Interpretation: 37.80% der Befragten mit Aufstiegsfortbildung sind Frauen. 2.4.3 pro Gruppe 2: Spaltenprozente Wir können diese Tabelle auch mit Spaltenprozenten anzeigen lassen, indem wir die Option col verwenden: tabulate m1202 S1, col nofreq | is not a valid command name r(199); HÃ¶chster | Geschlecht Ausbildungsabschluss | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- Ohne Berufsabschluss | 5.91 5.01 | 5.46 duale o. schulische B | 43.48 49.69 | 46.56 Aufstiegsfortbildung | 10.67 6.58 | 8.64 Fachhochschule, Unive | 39.94 38.72 | 39.33 ----------------------+----------------------+---------- Total | 100.00 100.00 | 100.00 Für die Spaltenprozente werden die Werte in Bezug zu den Spaltensummen gesetzt. Also wird die Anzahl der 1x/Woche Internet nutzenden Frauen ins Verhältnis zur Zahl der befragten Frauen gesetzt: \\(\\frac{\\text{Anzahl der Frauen mit Aufstiegsfortbildung}}{\\text{Gesamtzahl der befragten Frauen}}\\) - Interpretation: 6.58% der befragten Frauen haben eine Aufstiegsfortbildung. Übung1 2.5 metrische Variablen Für metrisch skalierte Variablen mit deutlich mehr Ausprägungen können wir tabulate zwar theoretisch auch verwenden, allerdings wird eine Tabelle hier sehr schnell sehr unübersichtlich. Für metrische Variablen empfiehlt sich daher summarize als Überblicksbefehl: summarize zpalter | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 summarize zpalter kann auch mit su zpalter abgekürzt werden. Hier bekommen wir die Anzahl der Beobachtungen (Obs.), das arithmetische Mittel (Mean), sowie die Minimal- und Maximalwerte ausgegeben (Min&amp;Max). (zur Standardabweichung Std. Dev. kommen wir noch). summarize klappt auch mit mehreren Variablen auf einmal (bei F518_SUF handelt es sich um den monatlichen Bruttoverdienst der Befragten): summarize zpalter F518_SUF // klappt auch mit mehreren Variablen | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 F518_SUF | 16,635 3532.109 3530.928 1 72000 2.6 Nochmal von vorne: Daten neu laden Fälle gelöscht, die doch nötig ist? Missings falsch codiert? Das ist zwar ärgerlich, aber ein riesen Vorteil der DoFile-basierten Datenarbeit mit Stata ist die Reproduzierbarkeit. Wir können einfach nochmal von vorne anfangen. Dazu lesen wir die Original-Daten einfach erneut mit use ein. Allerdings ist dann eine Besonderheit zu beachten: use &quot;BIBBBAuA_2018_suf1.0.dta&quot; no; dataset in memory has changed since last saved Wir müssen erst den existierenden Datensatz mit clear löschen clear use &quot;BIBBBAuA_2018_suf1.0.dta&quot; oder die clear Option für use verwenden: use &quot;BIBBBAuA_2018_suf1.0.dta&quot;, clear 2.7 Speichern Natürlich können wir unsere Daten auch abspeichern, wenn alles wie gewünscht geklappt hat. Dafür gibt es den Befehl save, der analog zu use funktioniert. Wenn wir allerdings einfach wieder den Original-Datensatznamen angeben und in der Zwischenzeit Variablen erstellt oder gelöscht haben, dann bekommen wir folgende Fehlermeldung: cd ... save &quot;BIBBBAuA_2018_suf1.0.dta&quot; file BIBBBAuA_2018_suf1.0.dta already exists r(602); Wir geben also entweder einen anderen Dateinamen an: save &quot;BIBBBAuA_2018_suf1.0_NEU.dta&quot; Wir können aber auch mit der Option replace explizit mitteilen, dass die Datei überschrieben werden soll: save &quot;BIBBBAuA_2018_suf1.0.dta&quot;, replace Achtung: Damit sind die Originaldaten aber natürlich weg. 2.8 Übungen 2 2.8.1 Übung 2-1 Laden Sie die Erwerbstätigenbefragung in Stata. Die Variable F100_wib1 erfasst, ob die Befragten in einem wissensintensiven Beruf tätig sind (ja/nein). Lassen Sie sich eine Tabelle für F100_wib2 anzeigen. Welche ist die häufigste Ausprägung? Lassen Sie sich die Zahlencodes anstelle der Labels anzeigen (nolabel) Überschreiben Sie alle Codes für fehlende Angaben mit . Denken Sie an labelbook). Lassen Sie sich mit tabulate die Häufigkeitsauszählung erneut anzeigen. Hat sich die Fallzahl zu vorhin verändert? Wie können Sie die fehlenden Werte auch in tabulate auszählen lassen? Lassen Sie sich diese Auszählung anzeigen! Für wie viele Befragte liegt keine Angabe zum wissensintensiven Beruf vor? Nutzen Sie mdesc. Lassen Sie sich jetzt F100_wib2 getrennt nach der Wohnortgröße ausgeben. Die Variable gkpol beinhaltet die Größenklasse der Wohngemeinde der Befragten in 7 Kategorien (bis 2000 Einwohner, 2000-5000 Einwohner, usw.) Welche Merkmalskombination ist die häufigste? Welcher Anteil der Befragten aus Städten mit über 500.000 Einwohnern ist in einem wissenintensiven Beruf tätig? Wie hoch ist der Anteil der in einem wissenintensiven Beruf tätig Befragten, die in Orten mit unter 2.000 Einwohnern leben? Kommentieren Sie einen Ihrer bisherigen Befehle mit //! Probieren Sie auch aus, mit /// einen Befehl über mehrere Zeilen zu verteilen! 2.8.2 Übung 2-2 Die Variable F1104 beinhaltet das Jahr des Schulabschlusses. Verwenden Sie summarize um einen Überblick zu dieser Variable zu bekommen Welches Skalenniveau hat die Variable? Hat die Variable F1104 Werte, die Sie mit . ersetzen sollten? (Denken Sie an labelbook) Führen Sie ggf. die Umcodierung der problematischen Werte auf . durch, um sie so Stata kenntlich zu machen. Lassen Sie sich F1104 erneut mit summarize anzeigen: hat alles geklappt wie es soll? Für wie viele Befragte liegt kein Schulabschlussjahr vor? Nutzen Sie mdesc. "],["desc1.html", "3 Deskriptive Statistik 3.1 Metrische Variablen beschreiben 3.2 Übungen 3.3 Anhang: Einstellung für ssc install", " 3 Deskriptive Statistik 3.1 Metrische Variablen beschreiben Im vorherigen Kapitel bezog sich vor allem kategoriale Variablen (mit einer begrenzten Anzahl an Ausprägungen). Für ein metrisches Merkmal, wie zum Beispiel das Alter (zpalter) macht eine Häufigkeitstabelle wenig Sinn. 3.1.1 Lage- und Konzentrationsmaße Meist werden metrische Variablen mit Hilfe von Lage- und Konzentrationsmaßen beschrieben. Klassische Lagemaße zur Beschreibung von metrischen Variablen sind bspw. Minimum und Maximum, das arithm. Mittel sowie der Median und Quantile. Auch hier haben wir bereits den wichtigsten Befehl kennen gelernt: summarize gibt uns einen ersten Überblick zur Verteilung einer metrischen Variable: summarize zpalter | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 Wir erfahren also, dass die Befragten im Mittel 47.19228 Jahre alt sind, die jüngsten Befragten 15 Jahre alt und ältesten Befragten sind 87 Jahre alt. Mit der Option ,detail bekommen wir eine deutlich umfangreichere Auskunft: summarize zpalter, detail | is not a valid command name r(199); Alter der Zielperson ------------------------------------------------------------- Percentiles Smallest 1% 21 15 5% 27 16 10% 31 16 Obs 19,836 25% 38 16 Sum of Wgt. 19,836 50% 49 Mean 47.19228 Largest Std. Dev. 11.33762 75% 56 81 90% 61 82 Variance 128.5417 95% 63 83 Skewness -.3866576 99% 68 87 Kurtosis 2.377842 Hier wird eine ganze Menge auf einmal angezeigt - die Kennzahlen sind dabei in drei Spalten organisiert: Aus der ersten Spalte erfahren wir die Quantile (Percentiles). Ein Quantil einer Verteilung trennt die Daten so in zwei Teile, dass x% der Daten darunter und 100-x% darüber liegen. Hier können wir zB ablesen, dass 25% der Befragten 38 Jahre oder jünger sind. 95% der Befragten sind &lt;= 63 Jahre alt. Dementsprechend sind 5% der Befragten 63 Jahre oder älter. Die 50%-Grenze für das Alter (der Median) liegt bei 49 Jahren. die zweite Spalte gibt uns jeweils die 4 kleinsten und größten Werte für das Alter aus: die 4 kleinsten Alterswerte sind jeweils 15,16,16,16 die größten Werte sind 81,82,83 und 87. in der dritten Spalte bekommen wir eine Reihe weiterer Informationen: die Zahl der Beobachtungen (Obs) und das arithmetische Mittel (Mean) die Streuung anhand der Standardabweichung (Std. Dev.) und Varianz (Variance) sowie die Schiefe (Skewness) und Wölbung (Kurtosis) 3.1.2 tabstat Häufig möchten wir aber vielleicht nur eine bestimmte Information. Dafür ist tabstat eine gute Lösung. Mit tabstat können wir eine ganze Reihe statistischer Kennzahlen für metrische/kontinuierliche Merkmale berechnen. Die Syntax hat dabei das folgende Format: tabstat zpalter, s(*option*) Hier eine Übersicht der Kennzahlen: Option Kennzahl mean arithm. Mittel median Median count Anzahl der Beobachtungen ohne Missings n entspricht count sum Summe der Ausprägungen max Maximum min Minimum range Spannweite = max - min variance Varianz sd Standardabweichung cv Variationskoefficient (sd/mean) skewness Schiefe kurtosis Wölbung pX X. Perzentil (5,10,25,50,75,90,95,99) iqr Interquartilsdistanz = p75 - p25 q Entspricht p25 p50 p75 Hier ein Bespielbefehl für die Berechnung des arith. Mittels, des Medians, der Varianz und des Varianzkoeffizienten mit tabstat: tabstat zpalter, s(mean median var cv) | is not a valid command name r(199); variable | mean p50 variance cv -------------+---------------------------------------- zpalter | 47.19228 49 128.5417 .2402432 ------------------------------------------------------ Allerdings lassen sich mit tabstat nicht beliebige Quantil-Grenzen (nur für 5,10,25,50,75,90,95,99) berechnen, dafür können wir centile nutzen: centile age, centile(35) | is not a valid command name r(199); -- Binom. Interp. -- Variable | Obs Percentile Centile [95% Conf. Interval] -------------+------------------------------------------------------------- zpalter | 19,836 35 44 43 44 Aus den Angaben unter Centile erfahren wir, dass 35% der Befragten im Datensatz sind 44 Jahre alt oder jünger sind. Dementsprechend sind 65% der Befragten 44 Jahre oder älter. 3.1.3 Kennzahlen vergleichen mit tabstat Interessant sind diese Kennzahlen auch wieder erst im Vergleich zwischen Gruppen. Hierfür steht uns die by()-Option von tabstat zur Verfügung. Bspw. können wir die Altersangaben von Männern und Frauen vergleichen, indem wir in tabstat die Option by(S1) verwenden: tabstat zpalter, s(mean median var cv) by(S1) | is not a valid command name r(199); Summary for variables: zpalter by categories of: S1 (Geschlecht) S1 | mean p50 variance cv ---------+---------------------------------------- mÃ¤nnlich | 46.49079 49 141.0736 .2554795 weiblich | 47.90402 50 114.8336 .2236982 ---------+---------------------------------------- Total | 47.19228 49 128.5417 .2402432 -------------------------------------------------- Wir sehen hier also, dass sowohl das arith. Mittel als auch der Median des Befragtenalters bei Frauen höher ist als bei Männern. Außerdem ist die Streuung bei Männern höher als bei Frauen. Eine andere Option ist es, auf den if-Befehl zurückzugreifen - siehe hier 3.1.4 Gini-Koeffizient Zur Beschreibung der (Ungleich-)Verteilung von metrischen Variablen, insbesondere bei Einkommens- und Vermögensdaten wird häufig der Gini-Koeffizient verwendet. Der Gini-Koeffizient beruht auf der Fläche zwischen der Lorenzkurve und der Gleichverteilung. Auf der x-Achse werden die kumulierten Perzentile der Befragten abgetragen, auf der y-Achse die Perzentile des HH-Einkommens: Den Gini-Koeffizienten können wir mit fastgini berechnen, allerdings müssen wir diesen Befehl erst (einmalig) installieren: ssc install fastgini fastgini F518_SUF | is not a valid command name r(199); command fastgini is unrecognized r(199); end of do-file r(199); Leider funktioniert by(S1) bei fastgini nicht, wir müssen hier auf die Variante mit if zurückgreifen: fastgini F518_SUF if S1 == 1 | is not a valid command name r(199); command fastgini is unrecognized r(199); end of do-file r(199); fastgini F518_SUF if S1 == 2 | is not a valid command name r(199); command fastgini is unrecognized r(199); end of do-file r(199); \\(\\Rightarrow\\) Wo sind die Einkommen also ungleicher verteilt?1 Anmerkung: hier wurden die Missings in F518_SUF mit mvdecode F518_SUF, mv(99998/ 99999) ausgeschlossen. 3.2 Übungen Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). Analysieren Sie die Einkommensangaben (F518_SUF). Denken Sie daran, die fehlenden Werte für F518_SUF mit als Missing zu überschreiben! mvdecode F518_SUF, mv( 99998/99999) Betrachten Sie die Einkommensangaben mit summarize Für wie viele Beobachtungen haben Sie eine gültige Angabe (nicht-Missing)? Wo liegt das arith. Mittel für die Einkommensangaben? Wie können Sie sich den Median mit Hilfe von summarize ausgeben lassen? Bei welchem Wert liegt die 75%-Perzentilsgrenze? Verwenden Sie jetzt tabstat, um folgende Kennzahlen für F518_SUF zu berechnen: Das arithm. Mittel, den Median, das 25%- und 75%-Quartil sowie die Varianz und den Variationskoeffizienten - was sagen Ihnen die Werte jeweils? Berechnen Sie nun alle Werte getrennt für Männer und Frauen (Variable S1). Berechnen Sie den Gini-Koeffizenten für F518_SUF! Denken Sie daran, vor der ersten Verwendung fastgini zu installieren - siehe hier und Anhang 3.3 Anhang: Einstellung für ssc install HTTP proxy host: kessenich.ivbb.bund.de Port: 80 Der etwas höhere Wert des Gini-Koeffizienten legt nahe, dass die Einkommen bei Frauen (S1=2) etwas stärker ungleich verteilt als bei Männern (S1=1). "],["iflab.html", "4 if-Bedingungen 4.1 if-Bedingungen - nur manche Zeilen ansehen 4.2 Labels 4.3 Fehlende Werte 4.4 keep &amp; drop: Fälle dauerhaft löschen 4.5 Übungen 4", " 4 if-Bedingungen 4.1 if-Bedingungen - nur manche Zeilen ansehen Bisher haben wir uns immer auf den gesamten Datensatz bezogen. Häufig möchten wir aber nur bestimmte Beobachtungen berücksichtigen. Ein Beispiel war gerade eben schon der fastgini-Befehl, der keine by-Option hat. Wir können mit einer if-Bedingung mitteilen, dass wir lediglich die Beobachtungen mit S1==2 berücksichtigen möchten (also Frauen): fastgini F518_SUF if S1 == 2 Stata geht dann also alle Zeilen durch und verwendet nur diejenigen mit der entsprechenden Ausprägung. Einige Beispiele list zeigen die Möglichkeiten vielleicht etwas besser: Mit einer if-Bedingung können wir uns die Variablen S1 S3 S2_j und zpalter für 81-jährigen Befragten anzeigen lassen: list S1 S3 S2_j zpalter if zpalter == 81 +--------------------------------------+ | S1 S3 S2_j zpalter | |--------------------------------------| 5114. | männlic Abitur / 1936 81 | 5179. | männlic Abitur / 1936 81 | 6118. | männlic Realschu 1936 81 | 9045. | männlic Abitur / 1936 81 | 10517. | weiblich Hauptsch 1936 81 | +--------------------------------------+ Wichtig ist hier == - ein einfaches = wird in Stata für die Zuweisung von Werten verwendet wie wir noch sehen werden. Für if-Bedingungen stehen uns die üblichen Operatoren zur Verfügung: &gt;, &lt;, ==, &gt;=, &lt;=, != (ungleich) Dementsprechend können wir so Befragte auswählen, die vor 1936 geboren wurden: list S1 S3 S2_j zpalter if S2_j &lt; 1936 Das funktioniert auch mit anderen Befehlen, wie z.B. tabulate - so können wir beispielsweise auszählen, wie viele 81-jährige Frauen und Männer im Datensatz vorhanden sind: tabulate S1 if zpalter == 81 | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 4 80.00 80.00 weiblich | 1 20.00 100.00 ------------+----------------------------------- Total | 5 100.00 Wir sehen unter anderem an der Fallzahl (Total) in dieser Tabelle, dass hier nicht alle Fälle aus dem Datensatz berücksichtigt werden. Wir können auch mehrere Bedingungen setzen. Sollen beide zutreffen, verbinden wir die Bedingungen mit &amp; - zB. wenn wir 81-jährige Befragte mit einem Bruttoverdienst von unter 1000 Euro auswählen möchten: list S1 if zpalter &gt; 81 &amp; F518_SUF &lt; 1000 Mit | können wir hingegen Fälle auswählen, für welche die ein oder die andere Bedingung zutrifft: tabulate S1 if zpalter == 81 | F518_SUF &lt; 1000 // 81 Jahre alt oder unter 1000EUR Einkommen Mit inrange können wir Auswahlen auf einen Wertebereich eingrenzen - d.h. diese beiden Auswahlen führen zum gleichen Ergebnis (nur Befragte, die zwischen 20 und 30 Jahre alt sind): tabulate S1 if zpalter &gt;= 20 &amp; zpalter &lt;= 30 tabulate S1 if inrange(zpalter,20,30) Mit inlist können wir spezifische Werte angeben und so lange Folgen von | vermeiden: tabulate S1 if zpalter == 15 | zpalter == 79 | zpalter == 80 | zpalter == 82 tabulate S1 if inlist(zpalter,15,79,80,82) 4.2 Labels Genauso könnten wir auch vorgehen wenn wir nur männliche oder weibliche Befragte betrachten möchten. Hier nochmal die Auszählung der Variable S1: tabulate S1 | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,074 50.34 50.34 weiblich | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 Allerdings sind männlich und weiblich lediglich Variablenlabels. D.h. hier wurden Zahlencodes wieder mit Beschreibungen verbunden. Wir können diese Labels nicht für if-Bedingungen verwenden: tab S1 if S1 == &quot;weiblich&quot; type mismatch r(109); Im Hintergrund ist S1 nämlich eine numerische Variable describe S1 | is not a valid command name r(199); storage display value variable name type format label variable label ------------------------------------------------------------------------------------------ S1 byte %8.0g S1 Geschlecht Unter value label sehen wir, dass hier das Label S1 angefügt wurde. Wir können die eigentlichen Werte in tabulate mit der Option ,nol ausblenden: tabulate S1, nol | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- 1 | 10,074 50.34 50.34 2 | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 Wenn wir also nach Frauen filtern möchten, müssen wir den entsprechenden Zahlencode angeben: tab S1 if S1 == 2 | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- weiblich | 9,938 100.00 100.00 ------------+----------------------------------- Total | 9,938 100.00 Mehr zu labels hier 4.3 Fehlende Werte Eine häufige Fehlerquelle bei fehlende Werten in Stata ist deren Verhältnis zu &gt;. Fehlende Werte werden nämlich von Stata als unendlich groß gewertet! Wenn wir uns Befragte mit einem Alter über 92 ausgeben lassen, dann bekommen wir auch diejenigen ohne Altersangabe ausgegegeben: list S1 S3 zpalter if zpalter &gt; 81 +-------------------------------+ | S1 S3 zpalter | |-------------------------------| 39. | weiblich Abitur / . | 514. | weiblich Abitur / 83 | 657. | männlic Hauptsch . | 823. | weiblich Realschu . | 982. | weiblich keine An . | |-------------------------------| | 150 weitere Zeilen | Es gibt zwei Möglichkeiten, dies zu umgehen: entweder wir verwenden inrange - wobei wir hier eine Obergrenze angeben müssen und außerdem die Untergrenze immer mit eingeschlossen wird. Wenn wir also nur Fälle sehen wollen, die älter als 81 sind, dann müssen wir einen Wert über 81 angeben: list S1 Bula zpalter if inrange(zpalter,81.5,100) oder wir hängen den missing()-Operator an die Bedingung an. Mit missing(zpalter) können wir alle Zeilen auswählen, für die zpalter missing ist. Wenn wir diesen mit Hilfe eines ! verneinen, können wir die fehlende Fällen ausschließen: list S1 Bula zpalter if zpalter &gt; 81 &amp; !missing(zpalter) Beide Befehle führen zum gleichen Ergebnis: +-------------------------------+ | S1 Bula zpalter | |-------------------------------| 514. | weiblich Hamburg 83 | 6438. | männlic Nordrhei 82 | 11786. | männlic Berlin 87 | +-------------------------------+ 4.4 keep &amp; drop: Fälle dauerhaft löschen Manchmal möchten wir nur bestimmte Beobachtungen im Datensatz behalten. Beispielsweise möchten wir für eine Analyse nur Befragte, die jünger als 30 Jahre sind, im Datensatz behalten. Dazu können wir keep oder drop die gewünschten Fälle behalten bzw. die ungewünschten ausschließen: keep if zpalter &lt; 30 Alternativ können wir auch mit drop alle Befragten aus dem Datensatz löschen, die 60 Jahre oder älter sind: drop if zpalter &gt;= 30 Mit describe, short sehen wir, dass wir jetzt deutlich weniger Fälle im Speicher haben: describe, short | is not a valid command name r(199); Contains data from D:\\Datenspeicher\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta obs: 1,639 vars: 683 11 Feb 2020 12:51 Sorted by: intnr Note: Dataset has changed since last saved. 4.5 Übungen 4 Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). In der Variable intnr ist die Interviewnummer abgelegt. Lassen Sie sich die Interviewnummer (intnr), Alter (zpalter), Geschlecht (S1) und die Wohnortgröße (gkpol) für den*die Befragte mit der Interviewnummer 2388097 ausgeben. Ersetzen Sie die Werte 9999 in zpalter mit .: mvdecode zpalter, mv(9999) Lassen Sie sich die Wohnortgröße (gkpol) für alle Befragte mit fehlender Altersangabe ausgeben. Lassen Sie sich eine Häufigkeitsauszählung der Wohnortgröße (tab gkpol) für folgende Gruppen ausgeben: Befragte, die jünger als 30 Jahre alt sind (das Alter ist in zpalter abgelegt) Befragte, die älter als 60 Jahre alt sind (Denken Sie an den Umgang mit Missings!) Befragte, die jünger als 30 Jahre alt und weiblich sind (das Geschlecht ist in S1 erfasst) Befragte, die zwischen 30 und 60 Jahre alt sind Befragte, die jünger als 30 Jahre alt sind oder älter als 60 Jahre alt sind Löschen Sie alle Beobachtungen von Befragten aus Städten mit 500.000 Einwohnern und mehr aus dem Speicher. Denken Sie an die Unterscheidung zwischen Labels und Zahlenwerten. "],["gen.html", "5 Variablen erstellen und verändern 5.1 gen ist gut, Kontrolle ist besser 5.2 Dummy-Variablen erstellen 5.3 Neue Variablen labeln 5.4 Bestehende Variablen verändern 5.5 Übungen", " 5 Variablen erstellen und verändern Natürlich sind wir nicht nur darauf beschränkt, bestehende Variablen anzusehen, sondern wir können auch neue Variablen erstellen. Das geht mit gen. Dazu geben wir erst den neuen Variablennamen an und nach =, wie die neue Variable bestimmt werden soll: gen alter_mon = zpalter * 12 su zpalter | is not a valid command name r(199); (176 missing values generated) Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- alter_mon | 19,836 566.3073 136.0515 180 1044 Wenn wir eine Variable überschreiben möchten, dann müssen wir diese erst mit drop löschen, bevor wir sie überschreiben. Würden wir den gen Befehl von gerade nochmal verwenden, dann bekommen wir eine Fehlermeldung: gen alter_mon = zpalter * 12 | is not a valid command name r(199); variable alter_mon already defined r(110); end of do-file r(110); Wir müssen den Namen age_mon also erst wieder frei machen, dann funktioniert der Befehl auch: drop alter_mon gen alter_mon = zpalter * 12 5.1 gen ist gut, Kontrolle ist besser Wie gerade gesehen gibt uns Stata aber keinerlei Erfolgsmeldungen. Nach der Bearbeitung oder Neuurstellung von Variablen sollte ein Blick in die Daten folgen. Dazu empfiehlt es sich, wieder auf den browse Befehl zurückzugreifen: browse intnr zpalter alter_mon In Kombination mit if können wir auch einige Spezialfälle betrachten, z.B. ob die Missings richtig verarbeitet wurden: browse intnr zpalter alter_mon if missing(zpalter) Häufig empfiehlt sich auch ein summarize und ein Vergleich der Missingszahl der alten und neuen Variable mit mdesc: summarize zpalter alter_mon mdesc zpalter alter_mon | is not a valid command name r(199); Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 19,836 47.19228 11.33762 15 87 alter_mon | 19,836 566.3073 136.0515 180 1044 command mdesc is unrecognized r(199); end of do-file r(199); 5.2 Dummy-Variablen erstellen Wir können auch die Operatoren aus den if-Bedingungen verwenden, um eine Variable zu generieren. Beispielsweise könnten wir eine Dummy-Variable bilden, ob die Befraten im gleichen Bundesland wohnen (Bula) und arbeiten (F233), indem wir den == Operator verwenden. Die entstehende Variable enthält dann immer eine 1 wenn beide Werte gleich sind, unterschiedliche Werte ergeben eine 0: mvdecode Bula F233, mv(97/99) gen ao_wo = Bula == F233 Die Ergebnisse solcher Veränderungen sollten immer überprüft werden! tab ao_wo browse Bula F233 ao_wo list Bula F233 ao_wo in 157/160 | is not a valid command name r(199); +-----------------------------+ | Bula F233 ao_wo | |-----------------------------| | Rheinlan Rheinlan 1 | | Rheinlan Baden-W 0 | | Rheinlan Rheinlan 1 | | Rheinlan . 0 | +-----------------------------+ Allerdings haben wir für F233 doch missings definiert - was passiert mit denen? mdesc Bula F233 ao_wo | is not a valid command name r(199); command mdesc is unrecognized r(199); end of do-file r(199); Leider gleicht Stata auch Missings mit gültigen Werten ab und vergibt dann dementsprechend 0 oder 1. Um die Missings als Missing zu behalten, müssen wir mit entsprechenden if-Bedingungen die Zeilen mit Missings in Bula und F233 ausschließen: drop ao_wo // löschen gen ao_wo = Bula == F233 if !missing(F233) &amp; !missing(Bula) mdesc Bula F233 ao_wo | is not a valid command name r(199); command mdesc is unrecognized r(199); end of do-file r(199); tab ao_wo | is not a valid command name r(199); ao_wo | Freq. Percent Cum. ------------+----------------------------------- 0 | 1,769 8.97 8.97 1 | 17,958 91.03 100.00 ------------+----------------------------------- Total | 19,727 100.00 5.3 Neue Variablen labeln Die so erstellte Dummy-Variable können wir auch labeln. Dazu definieren wir zunächst ein Wertelabel. Dazu verwenden wir label define, gefolgt von einem Objektnamen für dieses Label (hier aowo_lab) und dann jeweils die Ausprägungen zusammen mit dem entsprechenden Label in . Dieses Label-Objekt wenden wir dann mit label values auf die Variable ao_wo an: label define aowo_lab 0 &quot;ungleich&quot; 1 &quot;gleich&quot; label values ao_wo aowo_lab tab ao_wo | is not a valid command name r(199); ao_wo | Freq. Percent Cum. ------------+----------------------------------- ungleich | 1,769 8.97 8.97 gleich | 17,958 91.03 100.00 ------------+----------------------------------- Total | 19,727 100.00 Wenn wir das Label verändern, sehen wir das anschließend auch in tabulate: label define aowo_lab 0 &quot;Ungleich&quot; 1 &quot;Gleich&quot;, replace tab ao_wo | is not a valid command name r(199); ao_wo | Freq. Percent Cum. ------------+----------------------------------- Ungleich | 1,769 8.97 8.97 Gleich | 17,958 91.03 100.00 ------------+----------------------------------- Total | 19,727 100.00 Übung 5.4 Bestehende Variablen verändern Natürlich können wir auch bestehende Variable verändern, ein Beispiel hatten wir mit mvdecode bereits kennen gelernt. Während es bei mvdecode ja aber nur um Missings geht, gibt es auch Möglichkeiten die gültigen Werte zu verändern. 5.4.1 recode Mit recode können wir Werte in einer bestehenden Variable verändern. Die veränderten Werte können wir in der bestehenden Variable überschreiben. Die häufig bessere Variante ist aber, die Originalwerte zu behalten und die veränderten Werte in einer neuer Variable abzulegen. Das geht mit der Option ,into(neuer_variablenname) Beispielsweise könnten wir gkpol zu weniger Kategorien zusammenfassen - zur Erinnerung, das waren die Originalausprägungen: gkpol neue Variable Wert Label Kategorien 1 unter 2.000 Einwohner 1 - Klein 2 2.000 bis unter 5.000 Einwohner 1 - Klein 3 5.000 bis unter 20.000 Einwohner 1 - Klein 4 20.000 bis unter 50.000 Einwohner 2 - Mittel 5 50.000 bis unter 100.000 Einwohner 2 - Mittel 6 100.000 bis unter 500.000 Einwohner 3 - Groß 7 500.000 und mehr Einwohner 3 - Groß Mit recode können wir diese Ausprägungen zusammenfassen, indem wir immer (alt=neu) angeben. Umcodierungen sollten immer mit tab alt neu überprüft werden: recode gkpol (2=1) (3=1) (4=2) (5=2) (6=3) (7=3), into(gkpol2) tab gkpol gkpol2 | is not a valid command name r(199); (18928 differences between gkpol and gkpol2) | RECODE of gkpol Gemeindekennziffer | (Gemeindekennziffer politisch) politisch | 1 2 3 | Total ----------------------+---------------------------------+---------- unter 2.000 Einwohner | 1,084 0 0 | 1,084 2.000 bis unter 5.000 | 1,670 0 0 | 1,670 5.000 bis unter 20.00 | 5,002 0 0 | 5,002 20.000 bis unter 50.0 | 0 3,550 0 | 3,550 50.000 bis unter 100. | 0 1,624 0 | 1,624 100.000 bis unter 500 | 0 0 2,970 | 2,970 500.000 und mehr Einw | 0 0 4,112 | 4,112 ----------------------+---------------------------------+---------- Total | 7,756 5,174 7,082 | 20,012 Nicht erwähnte Ausprägungen werden einfach übernommen - daher ist 1 hier nicht aufgeführt. Ein Vorteil von recode ist, dass wir direkt Labels vergeben können, die wir einfach in \"\" anhängen - nochmal der gleich Befehl mit direkten Labels: drop gkpol2 // nochmal neu recode gkpol (2=1 &quot;Klein&quot;) (3=1 &quot;Klein&quot;) (4=2 &quot;Mittel&quot;) (5=2 &quot;Mittel&quot;) (6=3 &quot;Groß&quot;) (7=3 &quot;Groß&quot;), into(gkpol2) | is not a valid command name r(199); (18928 differences between gkpol and gkpol2) | RECODE of gkpol Gemeindekennziffer | (Gemeindekennziffer politisch) politisch | Klein Mittel Groß | Total ----------------------+---------------------------------+---------- unter 2.000 Einwohner | 1,084 0 0 | 1,084 2.000 bis unter 5.000 | 1,670 0 0 | 1,670 5.000 bis unter 20.00 | 5,002 0 0 | 5,002 20.000 bis unter 50.0 | 0 3,550 0 | 3,550 50.000 bis unter 100. | 0 1,624 0 | 1,624 100.000 bis unter 500 | 0 0 2,970 | 2,970 500.000 und mehr Einw | 0 0 4,112 | 4,112 ----------------------+---------------------------------+---------- Total | 7,756 5,174 7,082 | 20,012 Tricks, die alle aber zum gleichen Ergebnis führen: Wir können auch mehrere Werte vor dem = angeben: drop gkpol2 recode gkpol (1 2 3=1 &quot;Klein&quot;) (4 5=2 &quot;Mittel&quot;) (6 7=3 &quot;Groß&quot;), into(gkpol2) Außerdem können wir mit Hilfe von / auch Wertebereiche ansprechen: drop gkpol2 recode gkpol (1/3=1 &quot;Klein&quot;) (4/5=2 &quot;Mittel&quot;) (6/7=3 &quot;Groß&quot;), into(gkpol2) Wir können in recode auch folgende Hilfsausdrücke verwenden, bspw. recode gkpol .... (6/max =3 \"Groß\"),....: expr expl min Minimalwert max Maximalwert (missings werden hier ausnahmsweise nicht mit eingeschlossen) else or * alle anderen Werte miss alle missing Werte, die nicht von einer anderen Regeln angesprochen werden nonmiss alle nicht-missing Werte, die nicht von einer anderen Regeln angesprochen werden Übung 5.4.2 replace: Informationen aus mehreren Variablen in einer Variable zusammenführen Ein weiterer nützlicher Befehl ist replace. Hier können wir bestehende Variable verändern. Das ist inbesondere in Zusammenspiel mit if-Bedingungen hilfreich. Manchmal liegt eine interessierende Information aufgeteilt auf mehrere Variablen vor. Ein Beispiel hierfür ist die Erwerbskonstellation von Paaren in der Erwerbstätigenbefragung. Wir können aus den Informationen F1600 (Familienstand), F1601 (leben die Befragten mit der*der Partner*in zusammen?) und F1603 (ist Partner*in berufstätig?) eine Variable mit 3 Ausprägungen bauen: 1 nicht verh./alleine lebend 2 verh. &amp; 2 Erwerbspersonen im HH 3 verh. &amp; 1 Erwerbsperson gen erw_hh = . // leere Variable erstellen replace erw_hh = 1 if F1601 == 2 // alleine -&gt; leben nicht zusammen replace erw_hh = 2 if F1601 == 1 &amp; F1603 == 1 // zusammenlebend, Partner*in erwerbstätig replace erw_hh = 3 if F1601 == 1 &amp; F1603 == 2 // zusammenlebend, Partner*in nicht erwerbstätig replace erw_hh = 1 if inlist(F1600,2,3,4) // keine Partnerschaft -&gt; auch auf 1 *! unverheiratete werden hier nicht als Partnerschaften behandelt lab define erw_lab 1 &quot;nicht verh./alleine lebend&quot; 2 &quot;verh. &amp; 2 Erwerbspersonen im HH&quot; 3 &quot;verh. &amp; 1 Erwerbsperson&quot; lab values erw_hh erw_lab tab erw_hh Übung 5.5 Übungen Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). 5.5.1 Übung Erstellen Sie eine Dummy-Variable, die erfasst, ob die Befraten in der gleichen NUTS-2-Region leben und arbeiten nuts2 enthält den Wohnort, F233_nuts2 enthält den Ort der Betriebsstätte Schließen Sie die Missings aus (99996 bis 99999) Erstellen Sie die Variable mit gen. Denken Sie an den == Operator. Kontrollieren Sie das Ergebnis mit browse Definieren Sie Labels für diese Dummyvariable: Wohnort = Arbeitsort Wohnort != Arbeitsort Verändern Sie das Label S1 von 1 = männlich und 2= weiblich auf 1 = Männer und 2 = Frauen. Lassen Sie sich mit tab S1 die Variable ausgeben. Verändern Sie die Labels mit label define .... , replace Lassen Sie sich mit tab S1 die Variable erneut ausgeben - hat das geklappt wie gedacht? 5.5.2 Übung Fassen Sie die Variable Gesamtnote Schulabschluss (F1108) in drei Kategorien zusammen: F1108 neue Variable Wert Label neu 1 sehr gut 1 - (sehr) gut 2 gut 1 - (sehr) gut 3 befriedigend 2 - bestanden 4 ausreichend 2 - bestanden 7 keine Note vorgesehen 3 - fehlend 8 weiß nicht 3 - fehlend 9 keine Angabe 3 - fehlend Nutzen Sie die Label-Funktion von recode 5.5.3 Übung Fassen Sie die Variablen F209 ( Arbeitszeit normalerweise zwischen 7 und 19 Uhr?) und F223 (mindestens einmal im Monat Sonntagsarbeit) zu einer Variable a_zeit mit folgenden Ausprägungen zusammen: 1 zwischen 7-19 Uhr &amp; keine Sonntagsarbeit 2 nicht zwischen 7-19 Uhr, aber keine Sonntagsarbeit 3 zwischen 7-19 Uhr aber Sonntagsarbeit 4 nicht zwischen 7-19 Uhr und Sonntagsarbeit (Für Tipp weiter nach unten Scrollen) F209 == 1 &amp; F223 == 2 // 1 zwischen 7-19 Uhr &amp; keine Sonntagsarbeit F209 == 2 &amp; F223 == 2 // 2 nicht zwischen 7-19 Uhr, aber keine Sonntagsarbeit F209 == 1 &amp; F223 == 1 // 3 zwischen 7-19 Uhr aber Sonntagsarbeit F209 == 2 &amp; F223 == 1 // 4 nicht zwischen 7-19 Uhr und Sonntagsarbeit "],["egen.html", "6 Variablen erstellen (2), Hilfe verwenden 6.1 egen 6.2 Erklärungen für help und Stata-Begriffe 6.3 by 6.4 Übungen 6.5 Anhang", " 6 Variablen erstellen (2), Hilfe verwenden 6.1 egen Mit egen, den Extensions to generate, stehen eine ganze Menge an Funktionen zur Verfügung. Sehr hilfreich ist bspw. die Option cut zur Einteilung in Gruppen: egen age_cat = cut(zpalter), at(15 18 35 60 100 ) label tab age_cat | is not a valid command name r(199); (176 missing values generated) age_cat | Freq. Percent Cum. ------------+----------------------------------- 15- | 10 0.05 0.05 18- | 3,351 16.89 16.94 35- | 13,855 69.85 86.79 60- | 2,620 13.21 100.00 ------------+----------------------------------- Total | 19,836 100.00 Außerdem könnten wir bspw. eine Variable durchschnittsalter mit dem Mittelwert für zpalter erstellen: egen durchschnittsalter = mean(zpalter) Oder wir könnten den Vergleich des Wohn- und Arbeitsbundeslandes aus Kapitel 5 mit diff() durchführen: gen ao_wo = Bula == F233 if !missing(F233) egen ao_wo2 = diff( Bula F233_Bula) if !missing(F233) Das führt zum gleichen Ergebnis, allerdings könnten wir in diff() noch weitere Variablen für einen Abgleich einfügen (bspw. weitere Arbeitsorte). Eine Liste aller Optionen für egen findet sich unter help egen: 6.2 Erklärungen für help und Stata-Begriffe 6.2.1 numlist, varlist, varname Eine numlist ist eine Liste von Zahlen, die je nach Anwendungsfall durch Leerzeichen oder Kommas getrennt sind. Es gibt eine ganze Reihe von Möglichkeiten, eine numlist zu erzeugen. Im cut-Beispiel oben haben wir einfach in at() direkt die Zahlen angegeben und so eine numlist mit den Werten 15 18 35 60 100 erstellt. Wir können aber mit (start(intervall)stop) auch eine Zahlenreihe anlegen, bspw. mit (0(2)8) die Zahlenreihe 0, 2, 4, 6, 8. Eine numlist kann auch einer Reihe und einem Wert bestehen: 0(1)5 8 führt zu 0, 1, 2, 3, 4, 5, 8. Mehr Tricks unter help numlist. Eine varlist ist hingegen eine Liste an Variablennamen. Wenn wir eine solche aufrufen, werden die Namen mit den im Datensatz vorhandenen Variablen abgeglichen (und ggf. eine Fehlermeldung ausgegeben). Wir können varlisten einfach direkt angeben, bspw. wie in diff(bula F233), wir können aber auch Verallgemeinerungen, sog. wild cards für die Auswahl von Variablen verwenden: v l myvar nur Variable myvar myvar* Variablen, deren Name mit myvar beginnt, alsp bspw. auch myvar2 oder myvariable *var Variablen, deren Name mit var endet, alsp bspw. auch yourvar my*var Variablen deren Name mit my beginnt und mit var endet - mit einer beliebigen Zahl an Zeichen dazwischen my?var Variablen deren Name mit my beginnt und mit var endet - mit nur einem Zeichen dazwischen myvar1-myvar6 myvar1, myvar2, , myvar6 (je nachdem, welche Variablen vorhanden sind - in der Reihenfolge aus dem Variablenexplorer) Weiteres unter help varlist # steht in den Hilfe-Dateien immer für eine Zahl. 6.2.2 Beispielsyntax in den help Dateien Ganz unten finden sich in den Hilfen immer Beispiele: Diese beruhen auf Datensätzen, die lokal vorhanden sind (sysuse ...) oder direkt aus dem Internet geladen werden können (webuse). Oft ist es hilfreich, die Beispiele Schritt für Schritt durchlaufen zu lassen und im browse-Modus zu beobachten, was passiert. Übung 1 6.3 by Mit dem Präfix by können Berechnungen getrennt für verschiedene Gruppen durchgeführt werden. Das ist insbesondere in Kombination mit egen ein sehr vielseitiges Werkzeug. So können wir beispielsweise das Durchschnittsalter in unserem Datensatz getrennt für Frauen und Männer berechnen: by S1: egen mean_byS1 = mean(zpalter) not sorted r(5); Allerdings setzt das immer voraus, dass der Datensatz nach den in by angegebenen Variablen sortiert ist - sonst bekommen wir eine Fehlermeldung. Sortieren können wir entweder mit sort varname: sort S1 by S1: egen mean_byS1 = mean(zpalter) oder alles in einem Befehl: bysort S1: egen mean_byS1 = mean(zpalter) | is not a valid command name r(199); +--------------------------------+ | S1 zpalter mean_byS1 | |--------------------------------| | mÃ¤nnlic 41 46.49079 | | weiblich 51 47.90402 | | mÃ¤nnlic 49 46.49079 | | weiblich 63 47.90402 | | weiblich 41 47.90402 | +--------------------------------+ Anmerkung für die Ausgabe der Fälle wurde nach by S1,sort: egen mean_byS1 = mean(zpalter) mit sort intnr wieder die ursprüngliche Reihenfolge hergestellt. Wir könnten aber auch die geschlechts- und schulbildungsspezifischen Durchschnittseinkommen berechnen, indem wir beide Variablen im by-Befehl angeben: bysort S1 S3: egen mean_byS1S3 = mean(zpalter) | is not a valid command name r(199); +---------------------------------------------------------+ | S1 S3 zpalter mean_byS1 mean_byS1S3 | |---------------------------------------------------------| | mÃ¤nnlic Abitur / 41 46.49079 46.49431 | | weiblich Realschu 51 47.90402 48.09049 | | mÃ¤nnlic Fachhoch 49 46.49079 45.51706 | | weiblich Abitur / 63 47.90402 46.71193 | | weiblich Fachhoch 41 47.90402 46.8604 | +---------------------------------------------------------+ Übung 2 6.4 Übungen Laden Sie den BIBB/BAuA Erwerbstätigenbefragung 2018 (BIBBBAuA_2018_suf1.dta). 6.4.1 Übungen Bilden Sie mit Hilfe von egen verschiedene Einkommensklassen (bspw. ab 0EUR in 500EUR-Schritten bis 72000EUR). Nutzen Sie die numlist-Funktion mit (start(intervall)stop). Verändern Sie Labels. Welche Variablen bekommen Sie mit describe angezeigt, wenn Sie entweder describe F21, describe F21*, describe F21?, describe F2*4 oder describe F2?4 verwenden? 6.4.2 Übungen Berechnen Sie das Durchschnittseinkommen (basierend auf F518_SUF) getrennt für Männer und Frauen und legen Sie es in einer neuen Variable m_inc_byS1 ab. mit mvdecode F518_SUF, mv(99998/99999) können Sie die Missings ausschließen Denken Sie daran, dass Sie die Daten sortieren müssen. Wie würden Sie jetzt für jede*n Befragten berechnen, um wieviel ihr*sein Einkommen vom geschlechtsspezifischen Durchschnittswert unterscheidet? 6.4.3 Profiaufgabe Öffnen Sie die Hilfe für egen und lassen Sie ein Beispiel Schritt für Schritt durchlaufen - beobachten Sie was passiert, indem Sie mit browse den Datensatz betrachten. 6.5 Anhang 6.5.1 Kombination von summarize mit dem by-Präfix Mit bysort können wir auch Gruppenvergleiche erstellen. Bspw. können wir die Altersangaben für Männer (S1=1) und Frauen (S1=2) vergleichen, indem wir das Befehls-Präfix bys varX: verwenden. Stata sortiert also den Datensatz entsprechend der angegebenen Variable und die folgende Berechnung wird getrennt nach den Werten für varX ausgeführt. Wenn wir also summarize für beide Ausprägungen von S1 berechnen möchten, gehen wir wir folgt vor: bysort S1: summarize zpalter | is not a valid command name r(199); -------------------------------------------------------------------------------- -&gt; S1 = mÃ¤nnlic Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 9,990 46.49079 11.87744 16 87 -------------------------------------------------------------------------------- -&gt; S1 = weiblich Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- zpalter | 9,846 47.90402 10.71604 15 83 "],["zshg.html", "7 Zusammenhangsmaße 7.1 ttest 7.2 Mittelwertvergleiche mit dem t-Test 7.3 Übersicht zu Varianten für ttest 7.4 Korrelationskoeffizienten 7.5 Tabellenbasierte Zusammenhangsmaße 7.6 Übungen 7.7 Anhang", " 7 Zusammenhangsmaße Zusammenhänge sind das Herz (fast) aller statistischer Analysen. Im Folgenden lernen wir die Berechnung einer Reihe von Kennzahlen kennen, welche den Zusammenhang zwischen zwei Variablen ausdrücken. 7.1 ttest Ausgangsszenario: wir betrachten ein Merkmal und möchten durch eine Stichprobe überprüfen, ob der Mittelwert mit unserer Vermutung übereinstimmt bzw. größer/kleiner ist. Dies leisten die Hypothesentests, sog. t-Tests. Testen wir auf Übereinstimmung, verwenden wir einen sog. beidseitigen Test, bei einem einseitigen Test testen wir ob der Stichprobenwert signifikant größer bzw. kleiner als der vermutete Populationswert ist. Auch hier bleiben wir beim Durchschnittsalter der Erwerbstätigen - mit welcher Sicherheit können wir ausschließen, dass das Durchschnittsalter 47.4 Jahre ist? beidseitiger Test \\(H_0: \\mu = 47.4\\;Jahre\\) und \\(H_A: \\mu \\neq 47.4\\;Jahre\\) gerichtete Hypothesen: rechtsseitiger Test \\(H_0: \\mu \\leqslant 47.4\\;Jahre\\) und \\(H_A: \\mu &gt; 47.4\\;Jahre\\) \\(\\Rightarrow\\) die \\(H_A\\) postuliert, dass der wahre Wert größer als der Wert aus der \\(H_0\\) ist linksseitiger Test \\(H_0: \\mu \\geqslant 47.4\\;Jahre\\) und \\(H_A: \\mu &lt; 47.4\\;Jahre\\) \\(\\Rightarrow\\) die \\(H_A\\) postuliert, dass der wahre Wert kleiner als der Wert aus der \\(H_0\\) ist Wir berechnen also, mit welcher Irrtumswahrscheinlichkeit wir die \\(H_0\\) verwerfen können, von einem signifikanten Unterschied wird in der Regel gesprochen wenn die Irrtumswahrscheinlichkeit unter 5% liegt. Das bedeutet: Assuming that the null hypothesis is true and the study is repeated an infinite number times by drawing random samples from the same populations(s), less than 5% of these results will be more extreme than the current result.2 ttest berechnet immer die Ergebnisse für einen links-, beid- und rechtsseitigen t-Test. Neben den zu testenden Werten geben wir mit mu den in der Nullhypothese festgehaltenen Mittelwert an: ttest zpalter==47.4 | is not a valid command name r(199); One-sample t test ------------------------------------------------------------------------------ Variable | Obs Mean Std. Err. Std. Dev. [95% Conf. Interval] ---------+-------------------------------------------------------------------- zpalter | 19,836 47.19228 .0804998 11.33762 47.03449 47.35006 ------------------------------------------------------------------------------ mean = mean(zpalter) t = -2.5804 Ho: mean = 47.4 degrees of freedom = 19835 Ha: mean &lt; 47.4 Ha: mean != 47.4 Ha: mean &gt; 47.4 Pr(T &lt; t) = 0.0049 Pr(|T| &gt; |t|) = 0.0099 Pr(T &gt; t) = 0.9951 Der p-Wert unter mean &lt; 47.4 ist mit 0.0049 kleiner als 0,05, dementsprechend würden wir auf Basis eines linksseitigen Hypothesentests die \\(H_0\\) verwerfen. Das p-Wert unter mean != 47.4 liegt also deutlich unter 0,05. Wir würden also die \\(H_0\\) verwerfen, dass das Durchschnittsalter ür die Grundpopulation der Erwerbstätigen in D gleich 47.4 Jahre ist. Wir sehen unter mean &gt; 47.4, dass der p-Wert 0.9951 deutlich größer als 0,05 ist - dementsprechend würden wir auf Basis eines rechtsseitigen Hypothesentests die \\(H_0\\) nicht verwerfen. 7.2 Mittelwertvergleiche mit dem t-Test Diese Testlogik können wir auch dazu verwenden, Kennzahlen für verschiedene Gruppen zu vergleichen. 7.2.1 Unverbundener t-Test Eine häufige Frage zielt darauf ab zu analysieren, ob sich die Durchschnittswerte eines Merkmals zwischen zwei Gruppen unterscheiden. Beispielsweise könnten wir das Durchschnittsalter zwischen erwerbstätigen Männern und Frauen vergleichen. Auch für Gruppenvergleich müssen zunächst Hypothesen aufgestellt werden. Für einen beidseitigen Test ist die Alternativhypothese, dass es einen Gruppenunterschied gibt: \\(H_0: \\mu_1 - \\mu_2 = 0 \\qquad H_A: \\mu_1 - \\mu_2 \\neq 0\\) Ein linksseitiger Test hätte entsprechend die Alternativhypothese, dass der Gruppenunterschied kleiner als 0 ist: \\(H_0: \\mu_1 - \\mu_2 \\geqslant 0 \\qquad H_A: \\mu_1 - \\mu_2 &lt; 0\\) Ein rechtssseitiger Test hätte entsprechend die Alternativhypothese, dass der Gruppenunterschied größer als 0 ist: \\(H_0: \\mu_1 - \\mu_2 \\leqslant 0 \\qquad H_A: \\mu_1 - \\mu_2 &gt; 0\\) Wenn wir nun die beiden Mittelwerte für Männer und Frauen vergleichen, greifen wieder auf den ttest zurück, aber hier geben wir anstelle von == XYZ mit by(sex) die Gruppenvariable an. Mit unequal lassen wir zudem zu, dass die Varianz des Alters in beiden Gruppen unterschiedlich ist (was sehr häufig der Fall ist): ttest zpalter, by(S1) unequal | is not a valid command name r(199); Two-sample t test with unequal variances ------------------------------------------------------------------------------ Group | Obs Mean Std. Err. Std. Dev. [95% Conf. Interval] ---------+-------------------------------------------------------------------- mÃ¤nnlich | 9,990 46.49079 .1188339 11.87744 46.25785 46.72373 weiblich | 9,846 47.90402 .1079952 10.71604 47.69233 48.11571 ---------+-------------------------------------------------------------------- combined | 19,836 47.19228 .0804998 11.33762 47.03449 47.35006 ---------+-------------------------------------------------------------------- diff | -1.413231 .1605754 -1.727972 -1.09849 ------------------------------------------------------------------------------ diff = mean(mÃ¤nnlich) - mean(weiblich) t = -8.8010 Ho: diff = 0 Satterthwaite&#39;s degrees of freedom = 19681.3 Ha: diff &lt; 0 Ha: diff != 0 Ha: diff &gt; 0 Pr(T &lt; t) = 0.0000 Pr(|T| &gt; |t|) = 0.0000 Pr(T &gt; t) = 1.0000 Für die jeweiligen Tests ergeben sich folgende Entscheidungen: beidseitiger Test: Da der p-Wert für den beiseitigen Test (unter Ha: diff != 0) deutlich unter 0,05 liegt, können wir hier die \\(H_0\\) verwerfen und gehen von signifikanten Altersunterschieden aus. rechtsseitiger Test: für einen rechtsseitigen Test achten wir auf Ha: diff &gt; 0- die erwerbstätigen Männer sind also nicht signifikant älter als die erwerbstätigen Frauen. linksseitiger Test: für einen linksseitigen Test ist hingegen Ha: diff &lt; 0 ausschlaggebend: erwerbstätigen Männer sind also signifikant jünger als erwerbstätige Frauen. Übung 7.2.2 Verbundener t-Test Möchten wir Werte vergleichen, welche in einer Verbindung zueinander stehen, ist der verbundene t-Test die richtige Wahl. Beispiele für verbundene Stichproben sind beispielsweise experimentelle Untersuchungen, welche Daten vor und nach einer Maßnahme/Treatment/Intervention messen. Anschließend soll anhand des Vergleichs der Ergebnisse und die Wirkung der Maßnahme evaluiert werden. Hier sind die Messwerte aus den beiden Gruppen (vorher und nachher) miteinander verbunden - bspw. wird eine Person mit Bluthochdruck auch nach der Maßnahme in der Tendenz einen höheren Blutdruck haben als eine Person, welche bereits zuvor einen niedrigeren Blutdruck hatte. Ein fiktionales Beispiel: webuse bpwide browse bp_before bp_after Diese vorher/nachher Werte können wir jetzt mit einem verbundenen t-Test vergleichen: ttest bp_before==bp_after | is not a valid command name r(199); Paired t test ------------------------------------------------------------------------------ Variable | Obs Mean Std. Err. Std. Dev. [95% Conf. Interval] ---------+-------------------------------------------------------------------- bp_bef~e | 120 156.45 1.039746 11.38985 154.3912 158.5088 bp_after | 120 151.3583 1.294234 14.17762 148.7956 153.921 ---------+-------------------------------------------------------------------- diff | 120 5.091667 1.525736 16.7136 2.070557 8.112776 ------------------------------------------------------------------------------ mean(diff) = mean(bp_before - bp_after) t = 3.3372 Ho: mean(diff) = 0 degrees of freedom = 119 Ha: mean(diff) &lt; 0 Ha: mean(diff) != 0 Ha: mean(diff) &gt; 0 Pr(T &lt; t) = 0.9994 Pr(|T| &gt; |t|) = 0.0011 Pr(T &gt; t) = 0.0006 Auch hier sehen wir wieder die Ergebnisse für einen links- (Ha: mean(diff) &lt; 0) beid- (Ha: mean(diff) != 0) und rechtsseitigen (Ha: mean(diff) &gt; 0) Test. Wir erkennen aus den Ergebnissen, dass der Blutdruck der Patient*innen: nach dem Treatment nicht signifikant höher ist - linksseitiger Test (bp_before &lt; bp_after), linke Spalte sich vor und nach dem Treatment signifikant unterscheidet - beiseitiger Test (bp_before != bp_after), mittlere Spalte nach dem Treatment signifikant niedriger ist - rechtsseitiger Test (bp_before &gt; bp_after), rechte Spalte 7.3 Übersicht zu Varianten für ttest Für alle ttest-Varianten können wir mit , level(..) auch ein anderes Signifikanzniveau wählen. Standardmäßig wird \\(\\alpha=0,05\\%\\) verwendet. Vergleich zu einem Referenzwert: ttest testvariable == referenzwert Für Mittelwertvergleich gibt es insgesamt zwei Aspekte, anhand derer sich t-Tests unterscheiden: Die Varianz der Messwerte in den verglichenen Gruppen ist  gleich: \\(\\Rightarrow\\) ttest testvariable, by(gruppenvariable) verschieden: \\(\\Rightarrow\\) ttest testvariable, by(gruppenvariable) unequal (wie oben) Verbundene oder unverbundene Stichprobe? Sind die einzelnen Messwerte voneinander unabhängig? D.h. ein Messwert steht in keinem direkten Zusammenhang mit einem anderen \\(\\Rightarrow\\) ttest testvariable, by(gruppenvariable) für eine unverbundene Stichprobe (mit ggf. unequal) Stehen die einzelnen Messwerte in einem Zusammenhang? D.h. ein Messwert steht in einem direkten Zusammenhang mit einem anderen \\(\\Rightarrow\\) Werte für beide Variablen sollten nebeneinander abgelegt sein (wide-Format), dann kann mit ttest vorher==nachher ein verbundener ttest durchgeführt werden. 7.4 Korrelationskoeffizienten 7.4.1 Korrelation Zur Bestimmung eines Zusammenhangs zwischen zwei metrischen Variablen empfiehlt sich der Pearson-Korrelationskoeffizient: \\[r = \\frac{\\frac{1}{n}\\Sigma_{i}^{n}(x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\frac{1}{n}\\Sigma_{i}^{n}(x_i-\\bar{x})^2} \\times \\sqrt{\\frac{1}{n}\\Sigma_{i}^{n} (y_i-\\bar{y})^2}} = \\frac{cov_{xy}}{s_x \\times s_y}\\] In Stata können wir den Korrelationskoeffizienten mit pwcorr berechnen. Mit der Option ,sig werden zudem die p-Werte ausgegeben: pwcorr zpalter F231, sig | is not a valid command name r(199); | zpalter F231 -------------+------------------ zpalter | 1.0000 | | F231 | 0.0548 1.0000 | 0.0003 | Es handelt sich mit 0.0548 also um einen geringen Zusammenhang. Der p-Wert gibt uns auch hier wieder Auskunft über die stat. Signifikanz: mit 0.0003 liegt der p-Wert deutlich unter 0,05 \\(\\Rightarrow\\) wir würden hier die Nullhypothese verwerfen, dass die Korrelation in der Grundpopulation gleich Null ist. Um die Korrelationsmatrix zu erweitern, würden wir einfach zusätzliche Variablen angeben: pwcorr zpalter F231 F200 F1408, sig | is not a valid command name r(199); | zpalter F231 F200 F1408 -------------+------------------------------------ zpalter | 1.0000 | | F231 | 0.0548 1.0000 | 0.0003 | F200 | -0.0558 0.0768 1.0000 | 0.0000 0.0000 | F1408 | 0.2010 -0.0169 -0.2518 1.0000 | 0.0000 0.4396 0.0000 | 7.4.2 Rangkorrelation Zur Bestimmung der nicht-linearen Korrelation bzw. der Korrelation von ordinalen Merkmalen empfiehlt sich der Spearman-Rangkorrelationskoeffizient (\\(\\rho\\)). Wir können den Rangkorrelationskoeffizienten mit spearman berechnen: spearman zpalter F231 | is not a valid command name r(199); Number of obs = 4429 Spearman&#39;s rho = 0.0531 Test of Ho: zpalter and F231 are independent Prob &gt; |t| = 0.0004 Es zeigt sich also mit einem Korrelationskoeffizienten von 0.05 ein schwacher, positiver Zusammenhang. Für eine Korrelationsmatrix mit Rangkorrelationskoeffizienten müssen wir aber einen kleinen Umweg gehen und mit Hilfe von egen die Werte in Ränge umrechnen, um dann pwcorr verwenden zu können. 7.5 Tabellenbasierte Zusammenhangsmaße Ein klassisches ordinales Merkmal ist die Schulbildung, die wir aus S3 zusammenfassen können (Details im DoFile): Wir sehen uns den (möglichen) Zusammenhang zwischen der Schulbildung und F600_12 an: v l educ höchster Schulabschluss 1 max. Hauptschulabschluss 2 max. mittlere Reife 3 (Fach-)Abitur F600_12 Häufigkeit: unter Lärm arbeiten 1 häufig 2 manchmal 3 selten 4 nie So sieht die Verteilung zunächst in einer Kreuztabelle aus: tab F600_12 educ | is not a valid command name r(199); HÃ¤ufigkeit: | unter LÃ¤rm | educ arbeiten | Haupt m. Reife (Fach-)Ab | Total -------------+---------------------------------+---------- hÃ¤ufig | 927 1,525 1,631 | 4,083 manchmal | 522 1,130 1,657 | 3,309 selten | 437 986 1,748 | 3,171 nie | 912 2,685 5,565 | 9,162 -------------+---------------------------------+---------- Total | 2,798 6,326 10,601 | 19,725 7.5.1 Konkordanzmaße tab educ mi02 | is not a valid command name r(199); | HÃ¤ufigkeit: unter LÃ¤rm arbeiten educ | hÃ¤ufig manchmal selten nie | Total -----------+--------------------------------------------+---------- Haupt | 927 522 437 912 | 2,798 m. Reife | 1,525 1,130 986 2,685 | 6,326 (Fach-)Abi | 1,631 1,657 1,748 5,565 | 10,601 -----------+--------------------------------------------+---------- Total | 4,083 3,309 3,171 9,162 | 19,725 Zur Berechnung in Stata können wir ktau verwenden: ktau educ F600_12 | is not a valid command name r(199); Number of obs = 19725 Kendall&#39;s tau-a = 0.0965 Kendall&#39;s tau-b = 0.1517 Kendall&#39;s score = 18770040 SE of score = 780035.599 (corrected for ties) Test of Ho: educ and F600_12 are independent Prob &gt; |z| = 0.0000 (continuity corrected) Das positive Vorzeichen des Zusammenhangs deutet darauf hin, dass mit einer höheren Ausprägung von educ tendenziell höhere Werte für F600_12 einher gehen: eine höhere Schulbildung geht mit einem höheren Wert in F600_12 einher. Da höhere Werte in F600_12 seltenere Belastung angeben sind also Befragte mit höherer Schulbildung seltener von Lärm belastet. Der Wert von Kendalls \\(\\tau_a\\) ist deutlich niedriger als von Kendalls \\(\\tau_b\\), da hier der Nenner durch die Berücksichtigung aller möglichen Paarvergleiche größer wird, der Zähler aber für beide Varianten von Kendalls \\(\\tau\\) gleich definiert ist. Ein weiteres Maß ist Goodman &amp; Kruskals \\(\\gamma\\), dieses bekommen wir mit der Option ,gamma in tab: tab educ F600_12, gamma | is not a valid command name r(199); | HÃ¤ufigkeit: unter LÃ¤rm arbeiten educ | hÃ¤ufig manchmal selten nie | Total -----------+--------------------------------------------+---------- Haupt | 927 522 437 912 | 2,798 m. Reife | 1,525 1,130 986 2,685 | 6,326 (Fach-)Abi | 1,631 1,657 1,748 5,565 | 10,601 -----------+--------------------------------------------+---------- Total | 4,083 3,309 3,171 9,162 | 19,725 gamma = 0.2338 ASE = 0.009 Auch Goodman &amp; Kruskals \\(\\gamma\\) deutet auf einen negativen Zusammenhang hin, hier ist die Stärke mit (-0.5065) aber deutlich höher. Dies ist auf die Berücksichtigung der Bindungen zurückzuführen: hier werden alle Bindungen ausgeschlossen, also auch Paarvergleiche mit Bindungen nur auf einer Variable. Es reduziert sich also der Nenner, somit ergibt sich im Ergebnis ein höherer Koeffizient für Goodman &amp; Kruskals \\(\\gamma\\) als für Kendalls \\(\\tau_b\\). 7.5.2 Chi² &amp; Cramérs V \\(\\chi^2\\) basiert auf dem Vergleich der beobachteten Häufigkeit mit einer (theoretischen) Verteilung, welche statistische Unabhängigkeit abbildet (Indifferenztabelle - mehr dazu). Wir bleiben bei aq03 und dh01. Den \\(\\chi^2\\)-Wert für diese Häufigkeitstabelle bekommen wir mit , chi2: Mit der Option , V bekommen wir auch Cramérs V ausgegeben: tab F204 S1, chi V | is not a valid command name r(199); Wie wird Ihre | Mehrarbeit bzw. wie | werden Ihre | Ãberstunden | Geschlecht abgegolten? | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- durch Auszahlung | 536 400 | 936 durch Freizeitausglei | 1,924 2,308 | 4,232 durch beides | 1,458 873 | 2,331 keine Abgeltung | 1,120 740 | 1,860 ----------------------+----------------------+---------- Total | 5,038 4,321 | 9,359 Pearson chi2(3) = 225.4461 Pr = 0.000 CramÃ©r&#39;s V = 0.1552 Auf Basis dieses \\(\\chi^2\\)-Werts können wir Cramérs V berechnen. Dieses ist definiert als der Quotient aus dem \\(\\chi^2\\)-Wert und der Fallzahl multipliziert mit dem Minimum der Zeilen- und Spaltenzahl. n, erkennen wir aus dem Total rechts unten in der Tabelle. Außerdem hat unsere Tabelle 2 Zeilen und 4 Spalten, dementsprechend entspricht das Minimum hier 2: \\[ Cramer&#39;s\\,\\,V = \\sqrt{\\frac{\\chi^2}{n \\times min(k-1,m-1)}}=\\sqrt{\\frac{225.4461}{9359\\times(2-1)}} = 0.1552\\] Übung 7.6 Übungen Laden Sie die Erwerbstätigenbefragung in Stata. 7.6.1 Übung Testen Sie die Hypothese, dass die eigentliche durchschnittliche Arbeitszeit 38.5 Stunden beträgt. 7.6.2 Übung Testen Sie die Hypothese, dass ein signifikanter Unterschied in der Arbeitszeit (az) zwischen Männern und Frauen besteht (S1) 7.6.3 Übung Untersuchen Sie den Zusammenhang zwischen der Wochenarbeitszeit (az) und dem Einkommen (F518_SUF) der Befragten. Welches Maß ist das richtige? Denken Sie daran, die Missings in F518_SUF auszuschließen: mvdecode F518_SUF, mv(99998/99999), az hat keine Missings. Untersuchen Sie den Zusammenhang zwischen der Häufigkeit von starkem Termin- oder Leistungsdruck F411_01 und der dreistufigen Schulbildungsvariable educ. So können Sie educ erstellen: recode S3 (2/4 = 1 &quot;Haupt&quot;)(5/6 = 2 &quot;mittlere Reife&quot;) (7/9 = 3 &quot;(Fach-)Abi&quot;) (else = .), into(educ) Denken Sie daran, die Missings in F411_01 zu überschreiben: mvdecode F411_01, mv(9) Berechnen Sie ein oder mehrere geeignete Zusammenhangsmaße für diese beiden Variablen. 7.7 Anhang 7.7.1 Indifferenztabelle \\(\\chi^2\\) ergibt sich aus der Differenz zwischen der Indifferenztabelle und den beobachteten Häufigkeiten. Die Indifferenztabelle können wir mit ,expected aufrufen (mit nofreq blenden wir die tatsächlichen Häufigkeiten aus): tab F204 S1, expected nofreq | is not a valid command name r(199); | Geschlecht F204 | mÃ¤nnlich weiblich | Total ----------------------+----------------------+---------- durch Auszahlung | 503.9 432.1 | 936.0 durch Freizeitausglei | 2,278.1 1,953.9 | 4,232.0 durch beides | 1,254.8 1,076.2 | 2,331.0 keine Abgeltung | 1,001.2 858.8 | 1,860.0 ----------------------+----------------------+---------- Total | 5,038.0 4,321.0 | 9,359.0 7.7.2 Konkordanzmaße Für Konkordanzmaße wie Kendalls \\(\\tau\\) werden die Werteverhältnisse bzw. Paarvergleiche gezählt. Die Idee ist, dass aus den Tabellenwerten Paarvergleiche gebildet werden können: \\(\\tau_a\\): Differenz der konkordaten (C) und diskordanten (D) Paarvergleiche als Anteil an allen möglichen Paarvergleichen \\(\\frac{n\\times(n-1)}{2}\\): \\[\\tau_a=\\frac{C-D}{\\frac{n\\times(n-1)}{2}}\\] Nachteil: Bei Bindungen in X u. Y Maximalwerte (-1; +1) nicht zu erreichen \\(\\tau_b\\): Differenz der konkordaten (C) und diskordanten (D) Paarvergleiche als Anteil an allen möglichen Paarvergleichen \\(\\frac{n\\times(n-1)}{2}\\) unter Ausschluss von Bindungen in X und Y \\[\\tau_{b}=\\frac{C-D}{\\sqrt{(C+D+T_x)\\times(C+D+T_y)}}\\] Nachteil: Bei Bindungen in X o. Y Maximalwerte (-1; +1) nicht zu erreichen Goodman &amp; Kruskals \\(\\gamma\\) ignoriert die Bindungen vollständig: \\[\\gamma=\\frac{C-D}{C+D}\\] Um zu verdeutlichen wieviele Befragte jeweils das (ungefähr) gleiche Einkommen haben, wurden die Punkte hier nach links und rechts verschoben. Im Unterschied zu den bisherigen Streudiagrammen hat die relative Position innerhalb der Kategorien Männer und Frauen jedoch keine Bedeutung. "],["regression.html", "8 Regressionsmodelle 8.1 Regressionsmodelle - Grundlagen 8.2 kategoriale unabhängige Variablen 8.3 mehrere unabhängige Variablen 8.4 Übungen 8.5 Anhang", " 8 Regressionsmodelle 8.1 Regressionsmodelle - Grundlagen Regressionsmodelle zeigen uns den (linearen) Trend zwischen zwei Variablen. Hier geht es darum, um wie sich im Durchschnitt var2 verändert, wenn sich var1 um eine Einheit erhöht. var2 ist also unsere abhängige, var1 unsere unabhängige Variable - wir möchten var2 mit var1 vorhersagen. Im Folgenden sehen wir, dass Regressionsmodelle mit reg erstellt werden können und wie wir den Output interpretieren können. Falls Sie nochmal mehr zu den Grundlagen erfahren wollten, findet sich hier eine ausführlichere Erklärung. Wir betrachten einen kleinen Beispieldatensatz mit lediglich 4 Fällen und zwei metrischen Variablen var1 und var2: use &quot;https://github.com/filius23/Stata_Skript/raw/master/regression_bsp.dta&quot;, clear Mit Regressionsmodellen können wir lineare Zusammenhänge zwischen zwei metrischen Merkmalen untersuchen. In Stata können wir eine Regression mit dem reg Befehl berechnen: reg var2 var1 | is not a valid command name r(199); Source | SS df MS Number of obs = 4 -------------+---------------------------------- F(1, 2) = 11.07 Model | 12.4932432 1 12.4932432 Prob &gt; F = 0.0797 Residual | 2.25675676 2 1.12837838 R-squared = 0.8470 -------------+---------------------------------- Adj R-squared = 0.7705 Total | 14.75 3 4.91666667 Root MSE = 1.0623 ------------------------------------------------------------------------------ var2 | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- var1 | .5810811 .1746331 3.33 0.080 -.1703044 1.332467 _cons | 2.135135 .9485004 2.25 0.153 -1.945933 6.216203 ------------------------------------------------------------------------------ Hier steht jetzt eine ganze Menge an Informationen, die wir uns im Folgenden genauer ansehen werden. Allgemein sieht unsere Regressionformel wie folgt aus: \\[\\widehat{var2}=\\texttt{_cons} + \\beta1 \\times \\texttt{var1} = 2.1351 + 0.5810 \\times \\texttt{var1}\\] Ein positiver Wert unter Coef. in der Zeile von var1 bedeutet, dass unsere Gerade von links nach rechts ansteigt und ein negativer eine fallende Linie bedeuten würde. Der Wert unter var1 gibt an, um wieviel sich die Gerade pro Schritt nach rechts nach oben/unten verändert. Die Gerade steigt also pro Einheit von var1 um 0.5810811. Der Wert neben _cons gibt uns Auskunft darüber, wie hoch der vorhergesagte Wert für var2 wäre, wenn var1 = 0. Für var1 = 0 würden wir var2 = 2.135135 vorhersagen. Außerdem erkennen wir unter R-squared die Modellgüte unseres Regressionsmodells. \\(R^2\\) gibt die prozentuale Verbesserung der Vorhersgen durch die Gerade aus reg im Vergleich zum arithmetische Mittel an. \\(R^{2}\\) bezieht sich auf die Verringerung der Residuen durch das reg-Modell im Vergleich zur Mittelwertregel. Unser Regressionsmodell kann also 84,7% der Streuung um den Mittelwert erklären. Außerdem sehen wir oben links in der Spalte SS die Sum of Squares: unter Total ist die Summe der quadrierten Abweichungen der beobachteten Werte vom arith. Mittel angegeben (die Abstände zwischen den orangen und schwarzen Punkten: 14.75). Residual gibt die Summe der Abweichungsquadrate zwischen den beobachteten Werten und den vorhergesagten Werten der Regression (die Abstände zwischen den schwarzen und den blauen Punkten:2.256..). In der Spalte P&gt;|t| und t sehen wir die Ergebnisse eines t-Tests für die jeweiligen Koeffizienten. Hier wird der Koeffizient (sprich: die Steigung der Geraden) gegen Null getestet. Ist der Zusammenhang zwischen dem Alter der Befragten und ihrem Fernsehkonsum in der Population nicht eigentlich 0? \\[H_0:\\, \\mu_{Koeff(var1)} = 0 \\qquad H_A: \\mu_{Koeff(var1)} \\neq 0\\] Was hier also gemacht wird, ist ein t-Test für 0.5810811 vs. \\(\\mu=0\\). Unter P&gt;|t| erkennen wir hier aber, dass die Irrtumswahrscheinlichkeit für die Ablehnung der \\(H_0\\) größer als 0,05 ist. Dementsprechend verwerfen wir die Nullhypothese nicht (wonach \\(\\beta1\\) = 0 ist) und können hier nicht einen statistisch signifikanten Zusammenhang sprechen. 8.1.1 vorhergesagte Werte Die vorhergesagten Werte aus reg var2 var1 entsprechen einfach der Summe aus dem Wert neben _cons und dem Koeffizienten neben var1 multipliziert mit dem jeweiligen Wert für var1. Wir starten also sozusagen bei var2=0 und gehen dann eben x Schritte entlang der Geraden. reg var2 var1, noheader /// noheader macht den Output übersichtlicher | is not a valid command name r(199); ------------------------------------------------------------------------------ var2 | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- var1 | .5810811 .1746331 3.33 0.080 -.1703044 1.332467 _cons | 2.135135 .9485004 2.25 0.153 -1.945933 6.216203 ------------------------------------------------------------------------------ Vorhergesagte Werte für var2 werden mit \\(\\widehat{var2}\\) bezeichnet - das \\(\\widehat{}\\) steht dabei für geschätzt: \\[\\widehat{var2}=\\texttt{_cons} + \\beta1 \\times \\texttt{var1} = 2.1351 + 0.5810 \\times \\texttt{var1}\\] Für die erste Zeile ergibt sich also folgender vorhergesagter Wert: \\(2.1351+0.5811\\times1\\)= 2.7162 Wir könnten also auch einen vorhergesagten Wert für einen beliebigen Wert von var1 berechnen, für 5: \\(2.1351+0.5811\\times5\\)= 5.0406 Wir können dafür display 2.1351+0.5811*5 nutzen. Alternativ können wir uns die Tipparbeit auch sparen, indem wir erst reg laufen lassen und dann mit _b auf die Ergebnisse zugreifen: display _b[_cons] + _b[var1] * 5 | is not a valid command name r(199); 5.0405405 Mit predict können wir jeweils die vorhergesagten Werte für die Ausprägungen von var1 im Datensatz berechnen und in einer neuen Variable pred_vorher ablegen: predict pred_vorher, xb Hier wird also gerechnet: 2.1351 + 0.5810811 * 1 = 2.716216 2.1351 + 0.5810811 * 2 = 3.297297 2.1351 + 0.5810811 * 7 = 6.202703 2.1351 + 0.5810811 * 8 = 6.783784 var1 var2 pred_vorher mean_var2 1 1 2 2.716216 4.75 2 2 4 3.297297 4.75 3 7 7 6.202703 4.75 4 8 6 6.783784 4.75 Die Grafik oben zeigt die Vorhersagen auf Basis des Regressionsmodells: Sie entsprechen den Werten auf der blauen Geraden (der sog. Regressionsgeraden) an den jeweiligen Stellen für var1. Übung 8.2 kategoriale unabhängige Variablen Wir können aber auch kategoriale unabhängige Variablen in Regressionsmodellen verwenden. 8.2.1 Dummyvariablen Ein klassisches Beispiel für ene Dummyvariable aus unab. Variable in einem Regressionsmodell ist der Zusammenhang zwischen dem Geschlecht und dem Einkommen (Stichwort Gender Pay Gap). In der ETB 2018 ist das Geschlecht unter S1 abgelegt: 1 steht dabei für Männer, 2 steht für Frauen. Wie können wir S1 nun in das Regressionsmodell aufnehmen? Bisher hatten wir ja nur Modelle für metrische unabhängige und abhängige Variablen erstellt. Das Geschlecht ist aber kein metrisches Merkmal (\\(\\Rightarrow\\) sondern?). Die Zahlencodes sollten hier nicht als Werte verwendet werden. Hier gibt es keine Punktewolke, durch die sinnvoll eine Gerade durch Residuenminimierung gezogen werden kann: In einem Regressionsmodell müssen wir Stata mit dem Präfix i. mitteilen, dass es sich bei der Variable um eine kategoriale Variable handelt: reg F518_SUF i.S1 | is not a valid command name r(199); Source | SS df MS Number of obs = 16,635 -------------+---------------------------------- F(1, 16633) = 712.78 Model | 8.5219e+09 1 8.5219e+09 Prob &gt; F = 0.0000 Residual | 1.9886e+11 16,633 11955853.8 R-squared = 0.0411 -------------+---------------------------------- Adj R-squared = 0.0410 Total | 2.0738e+11 16,634 12467451.9 Root MSE = 3457.7 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- S1 | weiblich | -1431.809 53.63 -26.70 0.000 -1536.93 -1326.689 _cons | 4232.735 37.51532 112.83 0.000 4159.201 4306.269 ------------------------------------------------------------------------------ Der Koeffizient für S1 entspricht also der Differenz zwischen dem mittleren Einkommen für Männer und Frauen. Durch den Zusatz weiblich erhalten wir zusätzlich die Information über die Referenzkategorie: Befragte mit der Ausprägung S1 = 2, also Frauen, haben im Vergleich zu Befragten mit der anderen Ausprägung (\\(\\rightarrow\\) Männer) ein um 1431.809 EUR niedrigeres Einkommen. Der Zusammenhang zwischen Einkommen und dem Geschlecht der Befragten ist am 0,001-Niveau signifikant. Formal sieht unser Modell also so aus: \\[\\widehat{\\text{F518_SUF}} = \\hat{\\beta0} + \\hat{\\beta1} \\times \\texttt{S1=2}\\] Für S1=2 setzen wir dann entweder 0 oder 1 ein - je nachdem ob wir einen vorhergesagten Wert für Frauen oder für Männer berechnen wollen. 0 setzen wir immer dann ein, wenn wir einen Wert für die Referenzkategorie berechnen wollen: 4232.735 + -1431.809 \\(\\times 0\\) = 4232.735 Für Frauen sähe die Berechnung wie folgt aus - hier setzen wir die 1 ein, weil sozusagen sex2 zutrifft: 4232.735 + -1431.809 \\(\\times 1\\) = 2800.926 Die Logik folgt hier einem Gruppenvergleich zwischen den Gruppen. Wir vergleichen also die Mittelwerte zwischen verschiedenen Gruppen, in diesem Fall zwischen Männern und Frauen:3 Error in structure(list(fill = fill, colour = colour, size = size, linetype = linetype, : Objekt &#39;colorhex&#39; nicht gefunden Error in eval(expr, envir, enclos): Objekt &#39;theme_x&#39; nicht gefunden Wir können die Referenzkategorie natürlich auch ändern auf S1 = 2. Dazu geben wir ib2. an: reg F518_SUF ib2.S1 | is not a valid command name r(199); Source | SS df MS Number of obs = 16,635 -------------+---------------------------------- F(1, 16633) = 712.78 Model | 8.5219e+09 1 8.5219e+09 Prob &gt; F = 0.0000 Residual | 1.9886e+11 16,633 11955853.8 R-squared = 0.0411 -------------+---------------------------------- Adj R-squared = 0.0410 Total | 2.0738e+11 16,634 12467451.9 Root MSE = 3457.7 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- S1 | mÃ¤nnlich | 1431.809 53.63 26.70 0.000 1326.689 1536.93 _cons | 2800.926 38.32464 73.08 0.000 2725.806 2876.046 ------------------------------------------------------------------------------ Wie hier ist dann also die Interpretation umgekehrt: Befragte mit der Ausprägung S1 = 1, also Männer, haben im Vergleich zu Befragten mit der anderen Ausprägung (\\(\\rightarrow\\) Frauen) ein um 1431.81 EUR höheres Einkommen. Der Zusammenhang zwischen Einkommen und dem Geschlecht der Befragten ist am 0,001-Niveau signifikant. 8.2.2 Vergleich mit ttest reg F518_SUF i.S1 ttest F518_SUF,by(S1) | is not a valid command name r(199); Source | SS df MS Number of obs = 16,635 -------------+---------------------------------- F(1, 16633) = 712.78 Model | 8.5219e+09 1 8.5219e+09 Prob &gt; F = 0.0000 Residual | 1.9886e+11 16,633 11955853.8 R-squared = 0.0411 -------------+---------------------------------- Adj R-squared = 0.0410 Total | 2.0738e+11 16,634 12467451.9 Root MSE = 3457.7 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- S1 | weiblich | -1431.809 53.63 -26.70 0.000 -1536.93 -1326.689 _cons | 4232.735 37.51532 112.83 0.000 4159.201 4306.269 ------------------------------------------------------------------------------ Two-sample t test with equal variances ------------------------------------------------------------------------------ Group | Obs Mean Std. Err. Std. Dev. [95% Conf. Interval] ---------+-------------------------------------------------------------------- mÃ¤nnlich | 8,495 4232.735 42.87073 3951.324 4148.698 4316.772 weiblich | 8,140 2800.926 31.62129 2852.935 2738.94 2862.912 ---------+-------------------------------------------------------------------- combined | 16,635 3532.109 27.37647 3530.928 3478.448 3585.769 ---------+-------------------------------------------------------------------- diff | 1431.809 53.63 1326.689 1536.93 ------------------------------------------------------------------------------ diff = mean(mÃ¤nnlich) - mean(weiblich) t = 26.6979 Ho: diff = 0 degrees of freedom = 16633 Ha: diff &lt; 0 Ha: diff != 0 Ha: diff &gt; 0 Pr(T &lt; t) = 1.0000 Pr(|T| &gt; |t|) = 0.0000 Pr(T &gt; t) = 0.0000 8.2.3 Mehrere Ausprägungen Diese Logik des Gruppenvergleichs lässt sich auch auf kategoriale Variablen mit mehreren Ausprägungen erweitern, bspw. der Schulbildung der Befragten (educ - siehe DoFile für Vorbereitung): v l educ höchster Schulabschluss 1 max. Hauptschulabschluss 2 max. mittlere Reife 3 (Fach-)Abitur Wir müssen Stata wieder mit i. mitteilen, dass es sich um Gruppencodes (eine kategoriale Variable) handelt: reg F518_SUF i.educ | is not a valid command name r(199); Source | SS df MS Number of obs = 16,428 -------------+---------------------------------- F(2, 16425) = 366.95 Model | 8.7409e+09 2 4.3704e+09 Prob &gt; F = 0.0000 Residual | 1.9562e+11 16,425 11910111.4 R-squared = 0.0428 -------------+---------------------------------- Adj R-squared = 0.0427 Total | 2.0436e+11 16,427 12440764.2 Root MSE = 3451.1 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- educ | m. Reife | 258.8338 86.05536 3.01 0.003 90.15599 427.5116 (Fach-)Abi | 1633.935 80.55099 20.28 0.000 1476.046 1791.824 | _cons | 2579.348 71.71147 35.97 0.000 2438.786 2719.91 ------------------------------------------------------------------------------ Auch diese Koeffizienten sind als Gruppenvergleiche zu interpretieren - und zwar immer relativ zu der Ausprägung von educ, die nicht in der Regressionstabelle aufgeführt ist. (Hier also max. Hauptschule) Befragte mit mittlerer Reife haben ein um 258.83 Euro höheres Bruttoeinkommen als Befragte, die maximal einen Hauptschulabschluss haben. Der Zusammenhang ist am 0,01-Niveau signifikant.   Befragte mit (Fach-)Abitur verdienen 1633.93 Euro höheres Bruttoeinkommen als Befragte, die maximal Hauptschulabschluss haben. Der Zusammenhang ist am 0,001-Niveau signifikant.   Error in eval(expr, envir, enclos): Objekt &#39;theme_x&#39; nicht gefunden Formal sieht unser Modell also so aus: \\[\\widehat{\\texttt{F518_SUF}} = \\hat{\\beta0} + \\hat{\\beta1}\\times\\texttt{educ=2} + \\hat{\\beta2} \\times \\texttt{educ=3}\\] Für educ=2 wird nur dann eine 1 eingesetzt, wenn der/die Befragte mittlere Reife hat - alle anderen Variablen sind dann notwendigerweise auf 0 gesetzt. Für eine(n) Befragte*n mit max Hauptschulabschluss (also eine Person aus der Referenzkategorie) wird für alle Variablen die Null eingesetzt. Wir können die Referenzkategorie natürlich auch ändern, bspw. auf educ = 3 - dazu geben wir ib3. an: reg F518_SUF ib3.educ | is not a valid command name r(199); Source | SS df MS Number of obs = 16,428 -------------+---------------------------------- F(2, 16425) = 366.95 Model | 8.7409e+09 2 4.3704e+09 Prob &gt; F = 0.0000 Residual | 1.9562e+11 16,425 11910111.4 R-squared = 0.0428 -------------+---------------------------------- Adj R-squared = 0.0427 Total | 2.0436e+11 16,427 12440764.2 Root MSE = 3451.1 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- educ | Haupt | -258.8338 86.05536 -3.01 0.003 -427.5116 -90.15599 (Fach-)Abi | 1375.101 60.07426 22.89 0.000 1257.349 1492.853 | _cons | 2838.182 47.57088 59.66 0.000 2744.938 2931.426 ------------------------------------------------------------------------------ Übung 2 8.3 mehrere unabhängige Variablen Natürlich können wir auch mehrere unabhängige Variablen in unser Modell aufnehmen. Beispielsweise können wir so für die Wochenarbeitszeiten kontrollieren: \\[\\widehat{\\texttt{F518_SUF}} = \\beta0 + \\beta1\\times\\texttt{educ2} + \\beta2\\times\\texttt{educ3} + \\beta3\\times\\texttt{F200} + \\beta4\\times\\texttt{educ2}\\times\\texttt{F200}\\] reg F518_SUF i.educ F200 | is not a valid command name r(199); Source | SS df MS Number of obs = 14,480 -------------+---------------------------------- F(3, 14476) = 742.37 Model | 2.0190e+10 3 6.7301e+09 Prob &gt; F = 0.0000 Residual | 1.3124e+11 14,476 9065696.61 R-squared = 0.1333 -------------+---------------------------------- Adj R-squared = 0.1332 Total | 1.5143e+11 14,479 10458269.1 Root MSE = 3010.9 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- educ | m. Reife | 338.4655 78.50361 4.31 0.000 184.5883 492.3426 (Fach-)Abi | 1632.405 74.10677 22.03 0.000 1487.146 1777.664 | F200 | 110.7945 2.907157 38.11 0.000 105.0961 116.4929 _cons | -1341.138 120.729 -11.11 0.000 -1577.783 -1104.494 ------------------------------------------------------------------------------ Hier ändert sich dann die Interpretation: unter Konstanthaltung der Wochenarbeitszeit geben Befagte mit (Fach-)Abitur ein um 1632.40EUR höheres Einkommen als Befragte mit maximal Hauptschulabschluss an. Ein äußerst hilfreicher Befehl in diesem Zusammenhang ist margins bzw. marginsplot: margins, at( F200 = (15(5)45) educ = (1(1)3)) marginsplot 8.3.1 Interaktionsterme Wenn wir uns aber fragen, ob sich der Zusammenhang zwischen der Schulbildung und dem Einkommen mit der Wochenarbeitszeit verändert, benötigen wir einen Interaktionsterm: \\[\\widehat{\\texttt{F518_SUF}} = \\beta0 + \\beta1\\times\\texttt{educ2} + \\beta2\\times\\texttt{educ3} + \\beta3\\times\\texttt{F200} + \\beta4\\times\\texttt{educ2}\\times\\texttt{F200} + \\beta5\\times\\texttt{educ3}\\times\\texttt{F200}\\] reg F518_SUF i.educ##c.F200 | is not a valid command name r(199); Source | SS df MS Number of obs = 14,480 -------------+---------------------------------- F(5, 14474) = 465.76 Model | 2.0987e+10 5 4.1974e+09 Prob &gt; F = 0.0000 Residual | 1.3044e+11 14,474 9011913.45 R-squared = 0.1386 -------------+---------------------------------- Adj R-squared = 0.1383 Total | 1.5143e+11 14,479 10458269.1 Root MSE = 3002 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- educ | m. Reife | -349.9542 318.3893 -1.10 0.272 -974.038 274.1296 (Fach-)Abi | -663.3032 303.201 -2.19 0.029 -1257.616 -68.99055 | F200 | 70.78942 7.417587 9.54 0.000 56.25 85.32884 | educ#c.F200 | m. Reife | 19.18259 8.914635 2.15 0.031 1.708764 36.65641 (Fach-)Abi | 66.3379 8.467607 7.83 0.000 49.74031 82.9355 | _cons | 54.97775 266.958 0.21 0.837 -468.2941 578.2496 ------------------------------------------------------------------------------ Bei Interaktionstermen empfiehlt sich ganz besonders, einen marginsplot zu erstellen: margins, at( F200 = (15(5)45) educ = (1(1)3)) marginsplot 8.3.2 Quadratische Terme Wenn wir uns aber fragen, ob sich der Zusammenhang zwischen der Wochenarbeitszeit und dem Einkommen nicht-linear verläuft, also sich abflacht oder eine zusätzliche Stunde Arbeitszeit mit höheren zusätzlichen Einkommen einhergeht (keine kausale Aussage!): \\[\\hat{\\texttt{F518_SUF}} = \\beta0 + \\beta1\\times\\texttt{educ2} + \\beta2\\times\\texttt{educ3} + \\beta3\\times\\texttt{F200} + \\beta4\\times\\texttt{F200}\\times\\texttt{F200}\\] \\[\\hat{\\texttt{F518_SUF}} = \\beta0 + \\beta1\\times\\texttt{educ2} + \\beta2\\times\\texttt{educ3} + \\beta3\\times\\texttt{F200} + \\beta4\\times\\texttt{F200}^2\\] reg F518_SUF i.educ c.F200##c.F200 | is not a valid command name r(199); Source | SS df MS Number of obs = 14,480 -------------+---------------------------------- F(4, 14475) = 559.15 Model | 2.0266e+10 4 5.0665e+09 Prob &gt; F = 0.0000 Residual | 1.3116e+11 14,475 9061089.35 R-squared = 0.1338 -------------+---------------------------------- Adj R-squared = 0.1336 Total | 1.5143e+11 14,479 10458269.1 Root MSE = 3010.2 ------------------------------------------------------------------------------- F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] --------------+---------------------------------------------------------------- educ | m. Reife | 330.7006 78.52959 4.21 0.000 176.7725 484.6286 (Fach-)Abi | 1622.589 74.16567 21.88 0.000 1477.215 1767.964 | F200 | 154.9909 15.559 9.96 0.000 124.4933 185.4885 | c.F200#c.F200 | -.7509174 .2597017 -2.89 0.004 -1.259966 -.2418688 | _cons | -1910.881 231.0717 -8.27 0.000 -2363.811 -1457.951 ------------------------------------------------------------------------------- Bei quadratischen Termen empfiehlt sich ganz besonders, einen marginsplot zu erstellen: margins, at( F200 = (15(5)45) educ = (1(1)3)) marginsplot 8.4 Übungen Laden Sie die Erwerbstätigenbefragung. 8.4.1 Übung Berechnen Sie ein Regressionsmodell mit der Arbeitszeit (az) aus der Hauptbeschäftigung als abh. Variable und dem Alter der Befragten (zpalter) als unabh. Variable. Denken Sie daran, die Missings in zupalter zu überschreiben: mvdecode zpalter, mv(9999) Weclhe Richtung hat der Zusammenhang? Arbeiten ältere Befragte eher mehr oder eher weniger? Wie ist der Koeffizient zu interpretieren? Was können Sie über die Varianzaufklärung sagen? 8.4.2 Übung Berechnen Sie ein Regressionsmodell mit der Arbeitszeit (az) aus der Hauptbeschäftigung als abh. Variable und der Ausbildung der Befragten (m1202) als unabh. Variable: wie sind die Koeffizienten zu interpretieren? mvdecode m1202,mv(-1) 8.4.3 Übung Erstellen Sie ein multivariates Modell mit az als abhängiger Variable hat und der Ausbildung (m1202) und dem Alter der Befragten (zpalter) als unabhängiger Variable. Verändern Sie das multivariate Modell aus 4. um eine Interaktion zwischen der Ausbildung (m1202) und dem Alter der Befragten (zpalter) 8.5 Anhang 8.5.1 marginsplot anpassen marginsplot, /// graphregion(fcolor(white)) /// Hintergundfarbe (außerhalb des eigentlichen Plots) plot1(color(&quot;57 65 101&quot;) msize(small)) /// Farbe &amp; Größe für erste Gruppe ci1opts(color(&quot;57 65 101&quot;)) /// Farbe für Konfidenzintervalle der ersten Gruppe plot2(color(&quot;177 147 74&quot;) msize(small)) /// ci2opts(color(&quot;177 147 74&quot;)) /// plot3(color(&quot;16 15 20&quot;) msize(small)) /// ci3opts(color(&quot;16 15 20&quot;)) /// legend(cols(3) region(color(white) fcolor(white)) ) /// Spaltenzahl, Rahmen- &amp; Hintergrundfarbe für Legende xtitle(&quot;vertragl. vereinb. Arbeitsstunden&quot;) /// Achsentitel ylabel(,angle(0)) /// Achen ytitle(&quot;Einkommen (F518_SUF)&quot;) /// title(&quot;Titel&quot;) /// subtitle(&quot;Untertitel&quot;) /// caption(&quot;{it:Quelle: Erwerbstätigenbefragung 2018}&quot;, size(8pt) position(5) ring(5) ) mehr zu Stata-Grafiken weiterführende Informationen Um zu verdeutlichen wieviele Befragte jeweils das (ungefähr) gleiche Einkommen haben, wurden die Punkte hier nach links und rechts verschoben. Im Unterschied zu den bisherigen Streudiagrammen hat die relative Position innerhalb der Kategorien Männer und Frauen jedoch keine Bedeutung. "],["lit.html", "9 Literatur 9.1 Stata 9.2 Statistik-Lehrbücher", " 9 Literatur 9.1 Stata Kohler, U., &amp; Kreuter, F. (2017). Datenanalyse mit Stata: Allgemeine Konzepte der Datenanalyse und ihre praktische Anwendung (5., aktualisierte Auflage.). De Gruyter Oldenbourg. Link The Interguide to Stata Hilfeseiten der UCLA StataList-Forum Germán Rodríguezs Seiten enthalten viele Beispiele, Tricks und Erklärungen 9.2 Statistik-Lehrbücher Fokus auf Intuition und Beispiele: Diaz-Bone, R. (2019). Statistik für Soziologen (4., überarbeitete Auflage.). Link Kronthaler, F. (2014). Statistik angewandt. Springer Berlin Heidelberg. Link Urban, D., &amp; Mayerl, J. (2018). Angewandte Regressionsanalyse: Theorie, Technik und Praxis. Springer Fachmedien Wiesbaden. Link etwas formaler und ausführlicher: Backhaus, K., Erichson, B., Plinke, W., &amp; Weiber, R. (2016). Multivariate Analysemethoden: Eine anwendungsorientierte Einführung (14., überarbeitete und aktualisierte Auflage). Springer Gabler. Link Bortz, J., &amp; Schuster, C. (2010). Statistik für Human- und Sozialwissenschaftler (7th ed.). Springer. Link Wolf, C., &amp; Best, H. (Eds.). (2010). Handbuch der sozialwissenschaftlichen Datenanalyse (1. Aufl). VS Verlag für Sozialwissenschaften. Link "],["appendix.html", "10 Anhang - fortgeschrittene Themen 10.1 Gewichtung in Stata 10.2 Import und Aufbereitung aus Excel 10.3 adopath 10.4 log file 10.5 Beobachtungen markieren mit gen &amp; if 10.6 macros", " 10 Anhang - fortgeschrittene Themen 10.1 Gewichtung in Stata Bei der Datenanalyse ist man oft mit einer Stichprobe aus einer größeren Population konfrontiert und man möchte aus dieser Stichprobe Rückschlüsse auf die größere Population ziehen. Die meisten statistischen Verfahren für diese sog. Inferenzstatistik beruhen dabei auf der Annahme, dass die Stichprobe eine einfache Zufallsstichprobe ist. Bei einer solchen Stichprobe gelangen alle Elemente der Grundgesamtheit mit der gleichen Wahrscheinlichkeit in die Stichprobe. In der Praxis sind solche Stichproben aber die große Ausnahme. Häufig haben bestimmte Gruppen von Personen höhere Auswahlwahrscheinlichkeiten als andere. Kohler/Kreuter, S.1 Grundsätzlich sind in Stata drei Arten der Gewichtung verfügbar: pweight \\(\\Rightarrow\\) die Beobachtungen aus der Grundgesamtheit haben eine unterschiedliche Wahrscheinlichkeit, in der Stichprobe zu sein fweight \\(\\Rightarrow\\) jede Beobachtung kommt mehrfach vor (Hochrechnungsfaktor) aweight \\(\\Rightarrow\\) jede Beobachtung im Datensatz ist eigentlich ein Gruppenmittelwert, der auf mehreren Beobachtungen basiert Weiterlesen Wir können Gewichtungen in Stata auf zwei Weisen anwenden: Zum einen können die Daten mit dem Befehl svyset als Surveydaten definiert werden. Hierbei können Variablen spezifiziert werden, die Informationen über das Survey-Design enthalten, wie die Stratifizierung und die anzuwendende Gewichtungsvariable. Anschließende Analyseverfahren werden mit dem Befehlspräfix svy durchgeführt. In diesem Beispiel: tabulate S1 // ungewichtet | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,074 50.34 50.34 weiblich | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 (Mit format(%10.3f) können wir die Darstellung als scientific notation (1.1e+04) umgehen) svyset _n [pweight=gew2018] svy: tabulate S1 , col count format(%10.3f) | is not a valid command name r(199); pweight: gew2018 VCE: linearized Single unit: missing Strata 1: &lt;one&gt; SU 1: &lt;observations&gt; FPC 1: &lt;zero&gt; (running tabulate on estimation sample) Number of strata = 1 Number of obs = 20,012 Number of PSUs = 20,012 Population size = 20,012.017 Design df = 20,011 ---------------------------------- Geschlech | t | count column ----------+----------------------- mÃ¤nnlich | 10941.888 0.547 weiblich | 9070.129 0.453 | Total | 20012.017 1.000 ---------------------------------- Key: count = weighted count column = column proportion Allerdings steht das svy-Präfix nicht für jeden Befehl zur Verfügung. Außerdem können kein weiteren Präfixe neben svy verwendet werden - beispielsweise by. Daher steht auch eine Alternative zur Verfügung, bei der wir die Gewichtung bei jedem Auswertungsschritt einzeln angeben. In unserem Beispiel also tabulate S1 [fweight=gew2018] may not use noninteger frequency weights r(401); Allerdings akzeptiert Stata bei Häufigkeitsgewichten frequency weights, keine Gewichtungswerte mit Nachkommastellen. Leider führt ein einfaches Auf- oder Abrunden führt aber häufig zu falschen Ergebnissen: tabulate S1 [fweight=round(gew2018)] // runden führt zu Abweichung - Vergleich mit svy: Ergebnis | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,524 55.44 55.44 weiblich | 8,458 44.56 100.00 ------------+----------------------------------- Total | 18,982 100.00 Eine mögliche Lösung dieser Problematik ist es, zunächst die Gewichtungsvariable mit einer hohen Zahl (bspw.100 000) zu multiplizieren und anschließend auf ganze Werte zu runden: tabulate S1 [fweight=round(gew2018*100 000)] Das führt zu korrekten Verteilungen. Allerdings ist für die Ergebnisse jedoch zu beachten, dass die zu Grunde liegende Fallzahl anschließend wieder korrigiert werden muss (also in diesem Beispiel durch 100 000 geteilt werden muss). Der eigentliche Zweck von fweight ist aber, die Auszählung hochzugewichten. In der Erwerbstätigenbefragung können wir das mit gew2018_hr17, dem Hochrechnungsfaktor auf dem Mikrozensus 2017 erreichen: tabulate S1 [fweight = round(gew2018_hr17)] | is not a valid command name r(199); Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 20,467,753 54.68 54.68 weiblich | 16,966,432 45.32 100.00 ------------+----------------------------------- Total | 37,434,185 100.00 Die Fallzahl ist also hier dann deutlich größer als die im Datensatz vorhandenen Fälle \\(\\Rightarrow\\) jeder Fall im Datensatz steht für eine Vielzahl an Fällen. 10.1.1 Übung Erstellen Sie eine Häufigkeitsauszählung der Ausbildungsabschlüsse (m1202) - zunächst ohne und dann mit Gewichtung. Verwenden Sie sowohl die pweights als auch die fweights an. 10.2 Import und Aufbereitung aus Excel 10.2.1 Datenimport aus Excel-Datei Unter file -&gt; import -&gt; excel spreadsheet können wir einen Excel-Import erstellen, den Befehl aus dem Ausgabefenster können wir dann kopieren: import excel &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB1\\Stata_Einführung_BIBB\\Rohdaten.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow case(lower) clear // oder: cd &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB1\\Stata_Einführung_BIBB\\&quot; import excel &quot;Rohdaten.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow case(lower) clear * Überblick gewinnen list browse | is not a valid command name r(199); id x1 x2 x3 x4 x5 1. 1 2 1 1 4 3 2. 2 1 -9 -9 2 5 3. 3 -4 1 1 5 . 4. 4 -4 -9 -9 2 1 5. 5 -4 -4 0 2 5 6. 6 -4 -9 1 5 2 7. 7 -4 1 -4 2 3 8. 8 1 -9 0 4 1 9. 9 1 -9 -9 5 3 10. 10 -4 -4 0 4 3 11. 11 1 -4 0 3 . 12. 12 -4 0 -9 3 2 13. 13 2 -4 1 4 2 14. 14 -4 -4 -9 4 5 15. 15 1 0 -9 2 5 Hier eine kleine (Fantasie-)Doku zum Datensatz: Variablenname Beschreibung Details id Befragten-Identifikationsnummer x1 Geschlecht 1 = Frau, 2 = Mann, -4 keine Angabe x2 Haustiere? 0 = nein, 1 = ja, -4 keine Angabe, -9 Datenfehler x3 Frühaufsteher? 0 = nein, 1 = ja, -4 keine Angabe, -9 Datenfehler x4 indx1 - 5er Likert-Skala: 1 = trifft überhaupt nicht zu 5 = tifft voll zu x5 indx2 - 5er Likert-Skala: 1 = tifft voll zu 5 = trifft überhaupt nicht zu 10.2.2 Variablen umbenennen: rename Dann benennen wir die Variablen in sprechendere Namen um rename alt neu: rename x1 gender rename x2 pets rename x3 earlybird rename x4 indx1 rename x5 indx5 | is not a valid command name r(199); id gender pets earlyb~d indx1 indx5 1. 1 2 1 1 4 3 2. 2 1 -9 -9 2 5 3. 3 -4 1 1 5 . 4. 4 -4 -9 -9 2 1 5. 5 -4 -4 0 2 5 6. 6 -4 -9 1 5 2 7. 7 -4 1 -4 2 3 8. 8 1 -9 0 4 1 9. 9 1 -9 -9 5 3 10. 10 -4 -4 0 4 3 11. 11 1 -4 0 3 . 12. 12 -4 0 -9 3 2 13. 13 2 -4 1 4 2 14. 14 -4 -4 -9 4 5 15. 15 1 0 -9 2 5 10.2.3 Variablenbeschreibung: label variable label variable gender &quot;Geschlecht&quot; label variable pets &quot;Haustierbesitz?&quot; label variable earlybird &quot;Frühaufsteher&quot; label variable indx1 &quot;index1&quot; label variable indx5 &quot;index2&quot; | is not a valid command name r(199); 10.2.4 Werte labeln label values Mit .buchstabe können wir fehlende Werte unterscheidbar halten, so können wir sowohl keine Angabe als auch Datenfehler als Missing überschreiben und trotzdem beide Varianten unterscheidbar halten: tab gender replace gender = .k if gender == -4 tab gender tab gender, m label define gend_lab 1 &quot;Frau&quot; 2 &quot;Mann&quot; .k &quot;keine Angabe&quot; lab val gender gend_lab tab gender tab gender, m | is not a valid command name r(199); (8 real changes made, 8 to missing) Geschlecht | Freq. Percent Cum. ------------+----------------------------------- 1 | 5 71.43 71.43 2 | 2 28.57 100.00 ------------+----------------------------------- Total | 7 100.00 Geschlecht | Freq. Percent Cum. -------------+----------------------------------- Frau | 5 33.33 33.33 Mann | 2 13.33 46.67 keine Angabe | 8 53.33 100.00 -------------+----------------------------------- Total | 15 100.00 Für die weiteren Variablen können wir ähnlich vorgehen: lab def dummy_lab 0 &quot;Nein&quot; 1 &quot;Ja&quot; .k &quot;keine Angabe&quot; .d &quot;Datenfehler&quot; lab val earlybird dummy_lab tab earlybird recode earlybird (-9=.d) (-4=.k) * oder: replace earlybird = .k if earlybird == -4 replace earlybird = .d if earlybird == -9 tab earlybird,m | is not a valid command name r(199); (earlybird: 7 changes made) Frühaufstehe | r | Freq. Percent Cum. -------------+----------------------------------- Nein | 4 26.67 26.67 Ja | 4 26.67 53.33 Datenfehler | 6 40.00 93.33 keine Angabe | 1 6.67 100.00 -------------+----------------------------------- Total | 15 100.00 10.2.5 Fortgeschrittene Programmierung: foreach-Schleife help foreach zeigt alle Möglichkeiten für eine foreach-Schleife. Da wir hier Variablen bearbeiten möchten, ist foreach v of varlist die richtige Option. Siehe hier die Erklärungen zu varlist, numlist usw. foreach v of varlist earlybird pets { replace `v&#39; = .k if `v&#39; == -4 replace `v&#39; = .d if `v&#39; == -9 lab val `v&#39; dummy_lab } // oder foreach v of varlist earlybird pets { recode `v&#39; (-9=.d) (-4=.k) lab val `v&#39; dummy_lab } | is not a valid command name r(199); (earlybird: 7 changes made) (pets: 10 changes made) 10.2.6 Index bilden Um jetzt einen Index aus indx1 und indx2 zu bilden, müssen wir zuerst eine der beiden umdrehen. Zur Erinnerung: Variablenname Beschreibung Details x4 indx1 - 5er Likert-Skala: 1 = trifft überhaupt nicht zu 5 = tifft voll zu x5 indx2 - 5er Likert-Skala: 1 = tifft voll zu 5 = trifft überhaupt nicht zu Hier drehen wir also indx1 um: gen indx1_rev = 6 - indx1 // (max+1) - indexwert list indx*, abbreviate(10) | is not a valid command name r(199); +---------------------------+ | indx1 indx2 indx1_rev | |---------------------------| 1. | 4 3 2 | 2. | 2 5 4 | 3. | 5 . 1 | 4. | 2 1 4 | 5. | 2 5 4 | |---------------------------| 6. | 5 2 1 | 7. | 2 3 4 | 8. | 4 1 2 | 9. | 5 3 1 | 10. | 4 3 2 | |---------------------------| 11. | 3 . 3 | 12. | 3 2 3 | 13. | 4 2 2 | 14. | 4 5 2 | 15. | 2 5 4 | +---------------------------+ Damit können wir jetzt zum eigentlichen Index kommen. Die einfachste Möglichkeit ist einfach mit gen gen index = (indx1_rev + indx2)/2 // !missings list ind*, abbreviate(15) | is not a valid command name r(199); (2 missing values generated) +-----------------------------------+ | indx1 indx2 indx1_rev index | |-----------------------------------| 1. | 4 3 2 2.5 | 2. | 2 5 4 4.5 | 3. | 5 . 1 . | 4. | 2 1 4 2.5 | 5. | 2 5 4 4.5 | |-----------------------------------| 6. | 5 2 1 1.5 | 7. | 2 3 4 3.5 | 8. | 4 1 2 1.5 | 9. | 5 3 1 2 | 10. | 4 3 2 2.5 | |-----------------------------------| 11. | 3 . 3 . | 12. | 3 2 3 2.5 | 13. | 4 2 2 2 | 14. | 4 5 2 3.5 | 15. | 2 5 4 4.5 | +-----------------------------------+ Hier werden also in allen Zeilen, in denen (mind.) ein Wert Missing, also ., ist im Summenindex auch ein Missing ausgegeben. Wollen wir das nicht, können wir rowmean() aus egen verwenden: egen indexb = rowmean(indx1_rev indx2) list ind*, abbreviate(15) | is not a valid command name r(199); +--------------------------------------------+ | indx1 indx2 indx1_rev index indexb | |--------------------------------------------| 1. | 4 3 2 2.5 2.5 | 2. | 2 5 4 4.5 4.5 | 3. | 5 . 1 . 1 | 4. | 2 1 4 2.5 2.5 | 5. | 2 5 4 4.5 4.5 | |--------------------------------------------| 6. | 5 2 1 1.5 1.5 | 7. | 2 3 4 3.5 3.5 | 8. | 4 1 2 1.5 1.5 | 9. | 5 3 1 2 2 | 10. | 4 3 2 2.5 2.5 | |--------------------------------------------| 11. | 3 . 3 . 3 | 12. | 3 2 3 2.5 2.5 | 13. | 4 2 2 2 2 | 14. | 4 5 2 3.5 3.5 | 15. | 2 5 4 4.5 4.5 | +--------------------------------------------+ Häufig ist aber wahrscheinlich eine Zwischenlösung das Ziel, d.h. wir wollen vllt rowmean() nur anwenden, wenn eine Mindestanzahl an gültigen Werten vorliegt oder eine Höchstzahl an fehlenden Werten. Die Zahl der Missings in bestimmten Variablen können wir mit rowmiss() berechnen, die Zahl der gültigen Werte mit rownonmiss(). Anschließend können wir mit if eine entsprechende Einschränkung setzen: egen nonmiss = rownonmiss(indx1_rev indx2) egen miss = rowmiss(indx1_rev indx2) egen indexc = rowmean(indx1_rev indx2) if miss == 2 list ind* *miss, abbreviate(15) | is not a valid command name r(199); +----------------------------------------------------------------------+ | indx1 indx2 indx1_rev index indexb indexc nonmiss miss | |----------------------------------------------------------------------| 1. | 4 3 2 2.5 2.5 2.5 2 0 | 2. | 2 5 4 4.5 4.5 4.5 2 0 | 3. | 5 . 1 . 1 1 1 1 | 4. | 2 1 4 2.5 2.5 2.5 2 0 | 5. | 2 5 4 4.5 4.5 4.5 2 0 | |----------------------------------------------------------------------| 6. | 5 2 1 1.5 1.5 1.5 2 0 | 7. | 2 3 4 3.5 3.5 3.5 2 0 | 8. | 4 1 2 1.5 1.5 1.5 2 0 | 9. | 5 3 1 2 2 2 2 0 | 10. | 4 3 2 2.5 2.5 2.5 2 0 | |----------------------------------------------------------------------| 11. | 3 . 3 . 3 3 1 1 | 12. | 3 2 3 2.5 2.5 2.5 2 0 | 13. | 4 2 2 2 2 2 2 0 | 14. | 4 5 2 3.5 3.5 3.5 2 0 | 15. | 2 5 4 4.5 4.5 4.5 2 0 | +----------------------------------------------------------------------+ 10.2.7 exportieren compress // variablen auf minimale speichergröße bringen save &quot;Datensatz_ready.dta&quot;, replace Dieser Datensatz kann mit use geladen werden. 10.3 adopath Mit adopath können wir die Ordner anzeigen, wo die ados liegen. Mit which können wir den Speicherort eines ado ansehen: which mdesc | is not a valid command name r(199); command mdesc not found as either built-in or ado-file r(111); end of do-file r(111); Mit adopath ++ PFAD können wir ado aus zusätzlichen Ordner verwenden: adopath ++ &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataBIBB1\\Stata_Einführung_BIBB/u&quot; 10.4 log file Mit log-Files können wir alles mitprotokollieren, was im Outputfenster passiert. Wir starten ein log-File mit log using dateiname. Ab dann wird alles in dieser Datei mitgeschrieben, was wir uns im Outputfenster anzeigen lassen: log using &quot;C:\\Pfad\\zum\\Ordner/log/logfile.txt&quot;, text replace // mit replace wird die Datei ggf überschrieben * ------------------------------------------------ * * Alter, Bildung, Geschlecht in der ETB 2018 * ------------------------------------------------ * glo data &quot;D:\\Datenspeicher\\BIBB_BAuA/&quot; use &quot;${data}/BIBBBAuA_2018_suf1.0.dta&quot;, clear mvdecode zpalter, mv(9999) // dieses log enthält auch kommentare mvdecode m1202,mv(-1) // noch einen * ------------------------ * * Auswertung * ------------------------ * tab m1202 S1 su zpalter log close 10.5 Beobachtungen markieren mit gen &amp; if Die Kombination aus gen und if hilft uns, wenn wir eine Variable nur für einige Zeilen erstellen wollen. Das hilft insbesondere, wenn wir bestimmte Beobachtungen markieren wollen. Beispielsweise Frauen (S1 = 1), die einer Nebentätigkeit (nt = 1) nachgehen: gen nt_frauen = 1 if S1 == 1 &amp; nt == 1 | is not a valid command name r(199); (19,136 missing values generated) Nur wenn beide Bedingungen zutreffen, wird unter nt_frauen eine 1 abgelegt: list S1 nt nt_frauen in 19671/19675, clean noobs abb(12) | is not a valid command name r(199); S1 nt nt_frauen weiblich keine Ne . mÃ¤nnlic mindeste 1 weiblich keine Ne . mÃ¤nnlic mindeste 1 weiblich keine Ne . In der alltäglichen Arbeit hilft das manchmal, wenn man spezielle Fälle immer wieder aufrufen möchte und nicht immer die ausgeschriebenen if-Bedingungen verwenden möchte. 10.6 macros Macros ist die Sammelbezeichung für globals und locals in Stata. Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen. Definiert werden sie durch globalinhalt oder localinhalt - oft mit glo und loc als Abkürzungen. globals können dann mit $globalname/${globalname} aufgerufen werden, locals mit `localname' - ganz einfach bspw. mit dis[play]: glo x 1 dis ${x} | is not a valid command name r(199); 1 loc y 2 dis `y&#39; | is not a valid command name r(199); 2 Der Unterschied besteht vor allem darin, dass local macros lokal für ein spezifisches Programm verfügbar sind, globale macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind. Ein macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden: glo pfad &quot;D:\\Projekt\\daten\\BIBB_BAuA&quot; // wo liegt der Datensatz? dis &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot; | is not a valid command name r(199); D:\\Projekt\\daten\\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Wir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden: glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; Micha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
